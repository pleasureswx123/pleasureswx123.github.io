<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[pleasureswx123]]></title>
  <subtitle><![CDATA[记录点滴]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://pleasureswx123.github.io/"/>
  <updated>2015-02-13T02:18:40.978Z</updated>
  <id>http://pleasureswx123.github.io/</id>
  
  <author>
    <name><![CDATA[pleasureswx123]]></name>
    <email><![CDATA[pleasureswx123@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[js状态机与setTimeout的特殊应用]]></title>
    <link href="http://pleasureswx123.github.io/2015/02/12/js%E7%8A%B6%E6%80%81%E6%9C%BA%E4%B8%8EsetTimeout%E7%9A%84%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://pleasureswx123.github.io/2015/02/12/js状态机与setTimeout的特殊应用/</id>
    <published>2015-02-12T05:40:17.000Z</published>
    <updated>2015-02-13T02:16:18.000Z</updated>
    <content type="html"><![CDATA[<h5 id="js状态机，很有用的一种形式">js状态机，很有用的一种形式</h5>
<pre><code><span class="keyword">var</span> state = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">this</span>.count = <span class="number">0</span>;
    <span class="keyword">this</span>.fun = <span class="literal">null</span>;
    <span class="keyword">this</span>.nowcount = <span class="number">0</span>;

};
state.prototype = {
    load: <span class="function"><span class="keyword">function</span> <span class="params">(count, fun)</span> </span>{
        <span class="keyword">this</span>.count = count;
        <span class="keyword">this</span>.fun = fun;
        <span class="keyword">this</span>.nowcount = <span class="number">0</span>;
    },
    trigger: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="keyword">this</span>.nowcount++;
        <span class="keyword">if</span> (<span class="keyword">this</span>.nowcount &gt;= <span class="keyword">this</span>.count) {
            <span class="keyword">this</span>.fun();
        }
    }
};
<span class="function"><span class="keyword">function</span> <span class="title">method1</span><span class="params">()</span> </span>{
    s.trigger();
}
<span class="function"><span class="keyword">function</span> <span class="title">method2</span><span class="params">()</span> </span>{
    s.trigger();
}
<span class="keyword">var</span> s = <span class="keyword">new</span> state();

s.load(<span class="number">2</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{   <span class="comment">//初始状态与OK后的回调</span>
    <span class="built_in">console</span>.log(<span class="string">'执行完毕'</span>);
});

setTimeout(method1, <span class="number">1000</span>);
setTimeout(method2, <span class="number">1000</span>);
</code></pre><p>状态机形式一般用在多个任务同时进行的情况下，任务执行到某个阶段后去触发执行自定义的回调函数!<br>状态机是一种非常用的方法，可适用于多种应用场合，比如 Deferred 对象的 resolve -&gt; done   reject -&gt; fail;</p>
<p>我目前能想到的是肯定能应用于抽奖效果转盘的效果。</p>
<h5 id="setTimeout_的特殊应用">setTimeout 的特殊应用</h5>
<p><strong>按钮三次快速点击才触发事件</strong></p>
<pre><code><span class="keyword">var</span> num = <span class="number">0</span>,
    hander = <span class="number">0</span>;
<span class="function"><span class="keyword">function</span> <span class="title">btnClick</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (hander != <span class="number">0</span>){
        clearTimeout(hander);
        hander = <span class="number">0</span>;
    }
    num++;
    <span class="keyword">if</span> (num &gt;= <span class="number">3</span>) {
        Run();
        num = <span class="number">0</span>;
        <span class="comment">//num = 0;</span>
        <span class="comment">//console.log(num);</span>
        clearTimeout(hander);
        hander = <span class="number">0</span>;
    }
    <span class="built_in">console</span>.log(num);
    hander = setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        num = <span class="number">0</span>;
    }, <span class="number">300</span>);
}
<span class="function"><span class="keyword">function</span> <span class="title">Run</span><span class="params">()</span> </span>{
    <span class="built_in">console</span>.log(<span class="string">'Run'</span>);
}

&lt;input type=<span class="string">"button"</span> onclick=<span class="string">"btnClick()"</span> value=<span class="string">"快速点击三次触发"</span> /&gt;　
</code></pre><p>当很多次的点击事件触发之后，运行到setTimeout时，setTimeout会将function函数扔进队列中，<br>不会直接运行，只有很多次的点击事件运行完成之后，js才去询问事件队列里是否有需要运行的函数，这时才会运行setTimeout中的function函数。</p>
<p><strong>快速多次点击只触发最后一次</strong></p>
<pre><code><span class="keyword">var</span> hander = <span class="number">0</span>;
<span class="function"><span class="keyword">function</span> <span class="title">btnClick</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (hander != <span class="number">0</span>) {
        clearTimeout(hander);
        hander = <span class="number">0</span>;
    }
    hander = setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        Run();
    }, <span class="number">300</span>);
}
<span class="function"><span class="keyword">function</span> <span class="title">Run</span><span class="params">()</span> </span>{
    <span class="built_in">console</span>.log(<span class="string">'Run'</span>);
}

&lt;input type=<span class="string">"button"</span> onclick=<span class="string">"btnClick()"</span> value=<span class="string">"快速点击只触发最后一次"</span> /&gt;
</code></pre><p>当鼠标一直点击，点击事件一直在处于运行状态的时候，队列中的setTimeout是不会触发的，只有最后不点击的时候才去询问事件队列。</p>
]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[如何理解js单线程的问题]]></title>
    <link href="http://pleasureswx123.github.io/2015/02/11/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3js%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B/"/>
    <id>http://pleasureswx123.github.io/2015/02/11/如何理解js的单线程/</id>
    <published>2015-02-11T05:40:17.000Z</published>
    <updated>2015-02-13T02:10:28.000Z</updated>
    <content type="html"><![CDATA[<h5 id="为什么JavaScript是单线程？">为什么JavaScript是单线程？</h5>
<p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。</p>
<p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。<br>比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。<br>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。<br>所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<h5 id="任务队列">任务队列</h5>
<p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。<br>如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。<br>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。<br>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</p>
<blockquote>
<p>  同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；<br>  异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
</blockquote>
<p>javascript事件处理器在线程空闲之前不会运行</p>
<pre><code><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++){
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="built_in">console</span>.log(i);
    },<span class="number">0</span>);
}
</code></pre><p>setTimeout:</p>
<pre><code><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++){
    setTimeout((<span class="function"><span class="keyword">function</span><span class="params">(pars)</span></span>{
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{<span class="built_in">console</span>.log(pars)};
    })(i),<span class="number">0</span>);
}
</code></pre><p>setTimeout回调在while循环结束运行之前不可能被触发</p>
<pre><code><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;
setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>;
    <span class="built_in">console</span>.log(<span class="string">'time:'</span>,end-start,<span class="string">'ms'</span>);
},<span class="number">500</span>);
<span class="keyword">while</span>(<span class="keyword">new</span> <span class="built_in">Date</span> - start &lt;<span class="number">2000</span>){}
</code></pre><p>那运行到setTimeout函数时到底干了些什么事呢？<br>setTimeout函数只是在延时时间后把回调扔进队列中去</p>
<pre><code>$(<span class="string">'ID'</span>).onclick = <span class="keyword">function</span>(){};
var <span class="keyword">...</span>
......
</code></pre><p>onclick函数会把事件扔到队列中去，然后去执行下面的代码,在下面的代码没有运行完之前点击是毫无反应的。</p>
<pre><code>function a(){
    $<span class="built_in">.</span>get(<span class="string">'/asyncdata/userInfo'</span>,function(){
        console<span class="built_in">.</span><span class="keyword">log</span>(<span class="string">'success1'</span>);
    });
}
a();
<span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span>
<span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span><span class="attribute">...</span>
</code></pre><p>a函数执行后，不会直接发送请求，只是将get方法的url与里面的function函数放进了事件的队列里，待后面所有的程序执行完成之后，再询问队列里有没有东西，如果有再去执行队列里的</p>
<pre><code><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++){
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="built_in">console</span>.log(i);
    },<span class="number">0</span>)
}
</code></pre><p>for循环执行10次，每循环一下就执行一次setTimeout，也就是执行了10次setTimeout，每次setTimeout执行后，只是将里面的function放进一个队列里，也就是往队列里放了10个function，<br>把这10个function放进队列，但都没有直接运行，等待后面所有的程序执行完成之后，再去询问列队里有没有东西，如果有再去执行，所以for循环之后，i值就变成了10，所以会输出10个10；</p>
<pre><code><span class="built_in">console</span>.log(<span class="string">'最先输出'</span>);<span class="comment">//因为上述所有的函数只是进入了队列</span>
<span class="built_in">console</span>.log(<span class="string">'它会第二次输出'</span>);<span class="comment">//最后的这一句执行完成之后，js去询问队列里有没有事件，有的话就再去执行队列里的</span>
</code></pre><p>click:</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">()</span></span>{
    <span class="built_in">console</span>.log(<span class="string">'click事件'</span>)
}
$(<span class="string">'a'</span>).on(<span class="string">'click'</span>,b);
</code></pre><p>当程序读到这一行时，b方法不会执行，它会执行on方法，on方法执行后，只是将b方法放进了一个对象里，也可以简称是一个队列里，但这个里面的方法，是需要触发click的时候才去运行的。<br>不过点击触发之前，必须等待下面的每行代码运行完成之后，click才会起作用，如果下面的代码没有运行完，就click点击$(‘a’)，b方法也是不会执行的</p>
<pre><code>$.get(<span class="string">'/asyncdata/userInfo'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="built_in">console</span>.log(<span class="string">'success1'</span>);
 });
</code></pre><p>当程序读到这一块的时候，它不行运行，只是将它放进事件队列里，需要将下面所有的代码运行完成之后，才会去发送请求，请求完成后，才能去执行function。</p>
<p>这里面可以充分的体现出的是：js是一门单线程的语言，也就是说是在一条线程上运行程序。它不会 一条 线程正运行着，另外再并行一条 线程 去发送请求，如果这样的话，就变成多线程的语言了</p>
<p><strong>总上述：隐含着一个意思，即触发的每个事件都会位于堆栈的最底部。</strong></p>
<blockquote>
<p>  （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>  （2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>  （3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>  （4）主线程不断重复上面的第三步。</p>
</blockquote>
<p>这就是JavaScript 运行机制。<br>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p>
]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[如何理解js是一门弱类型的、动态型的语言]]></title>
    <link href="http://pleasureswx123.github.io/2015/02/10/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3js%E5%BC%B1%E7%B1%BB%E5%9E%8B%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80/"/>
    <id>http://pleasureswx123.github.io/2015/02/10/如何理解js弱类型动态语言/</id>
    <published>2015-02-10T05:40:17.000Z</published>
    <updated>2015-02-13T02:18:05.000Z</updated>
    <content type="html"><![CDATA[<h5 id="如何理解js是一门弱类型的、动态型的语言">如何理解js是一门弱类型的、动态型的语言</h5>
<pre><code>x = <span class="number">5</span>; <span class="regexp">//</span> <span class="number">5</span>
x = x + <span class="string">'A'</span>; <span class="regexp">//</span> <span class="string">'5A'</span>
</code></pre><p>上面代码中，变量x起先是一个数值，后来是一个字符串，类型完全由当前的值决定，这就叫弱类型。<br>弱类型的好处是十分灵活，可以写出非常简洁的代码。</p>
<blockquote>
<p>  x         可以一会是字符串，一会是浮点，这是动态。<br>  3/“1.5”   这个数字除字符串合法是弱类型（场合时自动帮你转类型）</p>
</blockquote>
<p>在Javascript中，变量是没有类型的，所以，你可以最初的时候声明为数字，然后在赋值为字符串，这叫动态类型。</p>
<p><strong>动态/静态类型</strong><br>值得是声明一个变量之后，它是否可以存储（指向）不同类型的变量。</p>
<p>比如C语言，变量声明的时候是数字类型的，这个变量就不能赋予整数类型的内容，这就是静态类型。<br>在Javascript中，变量是没有类型的，所以，<code>你可以最初的时候声明为数字，然后在赋值为字符串，这叫动态类型</code>。</p>
<p><strong>弱/强类型值的是</strong><br>是否允许不兼容的类型进行运算。</p>
<p>比如在Javascript中，“4”-3的结果是数字1，这里字符串和数字做运算了。<br>强类型语言不允许两个不兼容的类型之间运算，<code>弱类型的语言允许不兼容的类型之间运算</code>。</p>
]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[promise与Deferred]]></title>
    <link href="http://pleasureswx123.github.io/2015/02/08/promise%E4%B8%8EDeferred/"/>
    <id>http://pleasureswx123.github.io/2015/02/08/promise与Deferred/</id>
    <published>2015-02-08T05:40:17.000Z</published>
    <updated>2015-02-13T02:11:17.000Z</updated>
    <content type="html"><![CDATA[<p>$.Deferred</p>
<pre><code><span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span><span class="params">(dtd)</span></span>{
    <span class="keyword">var</span> tasks = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="built_in">console</span>.log(<span class="string">'OK'</span>);
        dtd.resolve();
    };
    setTimeout(tasks,<span class="number">5000</span>);
    <span class="keyword">return</span> dtd.promise();
};
$.Deferred(wait)
    .done(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="built_in">console</span>.log(<span class="string">'success'</span>);
    })
    .fail(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="built_in">console</span>.log(<span class="string">'faile'</span>);
    });
</code></pre><p>事件观察者模式：</p>
<pre><code><span class="keyword">var</span> PubSub = {
    handlers:{},
    on :<span class="function"><span class="keyword">function</span><span class="params">(eventType,handler)</span></span>{
        <span class="keyword">if</span>(!(eventType <span class="keyword">in</span> <span class="keyword">this</span>.handlers)){
            <span class="keyword">this</span>.handlers[eventType] = [];
        }
        <span class="keyword">this</span>.handlers[eventType].push(handler);
        <span class="keyword">return</span> <span class="keyword">this</span>;
    },
    emit :<span class="function"><span class="keyword">function</span><span class="params">(eventType)</span></span>{
        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);
        <span class="keyword">for</span>(<span class="keyword">var</span> i= <span class="number">0</span>,l=<span class="keyword">this</span>.handlers[eventType].length;i&lt;l;i++){
            <span class="keyword">this</span>.handlers[eventType][i].apply(<span class="keyword">this</span>,args);
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
};
</code></pre><p>get请求</p>
<pre><code>$.get(<span class="string">'/asyncdata/userInfo'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="built_in">console</span>.log(<span class="string">'success1'</span>);
});
$.when($.get(<span class="string">'/asyncdata/userInfo'</span>)).done(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="built_in">console</span>.log(<span class="string">'aasfsafsafatest'</span>)
});
</code></pre><p>上面这行代码与使用回调的写法是一样的</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">c</span><span class="params">()</span></span>{
    <span class="built_in">console</span>.log(<span class="string">'4444444'</span>);
}
<span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">(c)</span></span>{
    $.get(<span class="string">'/asyncdata/userInfo'</span>,c);
}
b(c);
</code></pre><p>这个也是一样的</p>
<pre><code><span class="keyword">var</span> fetchingData = $.get(<span class="string">'/asyncdata/userInfo'</span>);
fetchingData.done(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="built_in">console</span>.log(<span class="string">'success'</span>)
});
fetchingData.fail(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="built_in">console</span>.log(<span class="string">'fail'</span>)
});
</code></pre><p>Deferred对象：</p>
<pre><code> <span class="keyword">var</span> promptDeferred = <span class="keyword">new</span> $.Deferred();

 promptDeferred.always(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="comment">//扔到事件队列里去，等遇到Deferred对象执行reject或resolve方法时再去执行</span>
 <span class="built_in">console</span>.log(<span class="string">'11111111'</span>)
 });

 promptDeferred.done(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{  <span class="comment">//扔到事件队列里去，等遇到Deferred对象执行reject方法时再去执行</span>
 <span class="built_in">console</span>.log(<span class="string">'22222222'</span>)
 });

 promptDeferred.fail(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{  <span class="comment">//扔到事件队列里去，等遇到Deferred对象执行resolve方法时再去执行</span>
 <span class="built_in">console</span>.log(<span class="string">'3333333333'</span>)
 });

 promptDeferred.progress(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{  <span class="comment">//扔到事件队列里去，等遇到Deferred对象执行resolve方法时再去执行</span>
 <span class="built_in">console</span>.log(<span class="string">'44445555'</span>)
 });
</code></pre><p>Deferred就是Promis,更准确地说，Deferred是Promise的超集，它比promis多了一项关键特性：可以直接触发。<br>使用resolve(执行)或reject(拒绝)方法；<br>通俗一点讲也就是Deferred对象与Promis对象的区别在于：Deferred对象拥有resolve(执行)或reject(拒绝)这两个方法，而Promis对象是不具有这两个方法的。</p>
<pre><code> promptDeferred.<span class="keyword">notify</span>();  <span class="comment">//触发progress事件</span>
 promptDeferred.reject();   <span class="comment">//触发always与fail事件</span>
 promptDeferred.resolve();  <span class="comment">//触发always与done事件</span>
</code></pre><p>promise对象：</p>
<pre><code><span class="keyword">var</span> promise = $.get(<span class="string">'/mydata'</span>);
promise.done(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="comment">//扔到事件队列里去，等文件的所有代码运行完成之后再去执行</span>
    <span class="built_in">console</span>.log(<span class="string">'onSuccess'</span>);
});
promise.always(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="comment">//扔到事件队列里去，等文件的所有代码运行完成之后再去执行</span>
    <span class="built_in">console</span>.log(<span class="string">'always'</span>);
});
promise.fail(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="comment">//扔到事件队列里去，等文件的所有代码运行完成之后再去执行</span>
    <span class="built_in">console</span>.log(<span class="string">'onFailure'</span>);
});

<span class="keyword">var</span> errorPromise = $(<span class="string">'.error'</span>).fadeIn().promise();
errorPromise.done(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="comment">//promise对象等待fadeIn方法执行完成时就执行done事件</span>
    <span class="built_in">console</span>.log(<span class="string">'error'</span>)
}); <span class="comment">//fadeIn执行完成后会自动执行done方法；</span>

<span class="keyword">var</span> slideUpDeferred = <span class="keyword">new</span> $.Deferred();
$(<span class="string">'.menu'</span>).slideUp(slideUpDeferred.resolve);  <span class="comment">//slideUp执行完成后会由resolve去执行Deferred对象的done或always方法；</span>
</code></pre><p>onReady事件：</p>
<pre><code>$(onReady);
$(<span class="built_in">document</span>).ready(onReady);
$.ready.promise().done(onReady);
</code></pre><p>Deferred对象：</p>
<pre><code><span class="keyword">var</span> aDreamDeferred = <span class="keyword">new</span> $.Deferred();
aDreamDeferred.done(<span class="function"><span class="keyword">function</span><span class="params">(subject)</span></span>{ <span class="comment">//扔到事件队列里去不直接执行，直到碰到resolve事件时再去执行</span>
    <span class="built_in">console</span>.log(subject);
});
aDreamDeferred.resolve(<span class="string">'the JS event model'</span>);  <span class="comment">//执行done事件</span>


<span class="keyword">var</span> timing = <span class="keyword">new</span> $.Deferred();
timing.done(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{
    <span class="built_in">console</span>.log(data);
});
$.get(<span class="string">'/asyncdata/userInfo'</span>,timing.resolve(<span class="string">'data'</span>));
</code></pre><p>$.ajax</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">getReslut</span><span class="params">()</span></span>{
    $.ajax(<span class="string">'/asyncdata/userInfo'</span>)
        .done(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            <span class="built_in">console</span>.log(<span class="string">'111111111'</span>);
        })
        .fail(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            <span class="built_in">console</span>.log(<span class="string">'66666666'</span>)
        })
        .done(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{
            <span class="built_in">console</span>.log(data)
        })
}
getReslut();
</code></pre><p>$.when</p>
<pre><code><span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> tasks = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="built_in">console</span>.log(<span class="string">'OK'</span>);
    };
    setTimeout(tasks,<span class="number">5000</span>);
};
$.when(wait())
    .done(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{  <span class="comment">//直接运行最后才运行tasks</span>
        <span class="built_in">console</span>.log(<span class="string">'success'</span>);
    })
    .fail(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="built_in">console</span>.log(<span class="string">'faile'</span>);
    });
</code></pre>]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[html5 UI线程 worker]]></title>
    <link href="http://pleasureswx123.github.io/2015/02/03/html5-UI%E7%BA%BF%E7%A8%8BWorker/"/>
    <id>http://pleasureswx123.github.io/2015/02/03/html5-UI线程Worker/</id>
    <published>2015-02-03T05:40:17.000Z</published>
    <updated>2015-02-12T07:47:21.000Z</updated>
    <content type="html"><![CDATA[<h5 id="前述">前述</h5>
<p>单线程（Single-threaded）运行是JavaScript语言的设计目标之一，进而言之是保持JavaScript的简单。但是我必须要说，尽管JavaScript具有如此语言特质，但它绝不简单！我们所说的“单线程”是指JavaScript只有一个线程控制。是的，这点令人沮丧，JavaScript引擎一次只能做一件事。</p>
<h5 id="简介">简介</h5>
<h3 id="html5_UI线程_worker：">html5 UI线程 worker：</h3>
<p>Web Workers 是 HTML5 提供的一个javascript多线程解决方案，我们可以将一些大计算量的代码交由web Worker运行而不冻结用户界面。<br>Web Worker的基本原理就是在当前javascript的主线程中，使用Worker类加载一个javascript文件来开辟一个新的线程，起到互不阻塞执行的效果，并且提供主线程和新线程之间数据交换的接口：postMessage，onmessage。<br>“web workers处在一个严格的无DOM访问的环境里，因为DOM是非线程安全的。”</p>
<p>HTML5 中的 Web Worker 可以分为两种不同线程类型:</p>
<blockquote>
<p>  一个是专用线程 Dedicated Worker<br>  一个是共享线程 Shared Worker。</p>
</blockquote>
<p><img src="/img/mode/mode9.png" alt="Alt text"></p>
<p>html5 Worker对象：</p>
<pre><code><span class="keyword">var</span> calculationCache = {},
    calculationCallbacks = {},
    mathQorker = <span class="keyword">new</span> Worker(<span class="string">'calculator.js'</span>);

mathQorker.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>{
    <span class="keyword">var</span> message = e.data;
    calculationCache[message.formula] = message.result;
    calculationCallbacks[message.formula].forEach(<span class="function"><span class="keyword">function</span><span class="params">(callback)</span></span>{
        <span class="keyword">callback</span>(message.result);
    })
});

<span class="function"><span class="keyword">function</span> <span class="title">runCalculation</span><span class="params">(formula,callback)</span></span>{
    <span class="keyword">if</span>(formula <span class="keyword">in</span> calculationCache){
        <span class="keyword">return</span> <span class="keyword">callback</span>(calculationCache[formula]);
    }
    <span class="keyword">if</span>(formula <span class="keyword">in</span> calculationCallbacks){
        <span class="keyword">return</span> calculationCallbacks[formula].push(<span class="keyword">callback</span>);
    }
    mathQorker.postMessage(formula);
    calculationCallbacks[formula] = [<span class="keyword">callback</span>];
}
</code></pre><p>个人通俗的理解：<br>主线程的postMessage方法会触发专用线程的message方法，<br>专用线程的postMessage方法会触发主线程的message方法。<br>这样可使得两个线程之间来回进行通信。</p>
<pre><code><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'boknows.js'</span>);
worker.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>{
    console.log(e.data);
});
worker.postMessage(<span class="string">'football'</span>);
worker.postMessage(<span class="string">'testball'</span>);

<span class="comment">//boknows.js</span>
<span class="keyword">self</span>.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>{
    <span class="keyword">self</span>.postMessage(<span class="string">'Bo knows '</span> + e.data);
});
</code></pre><p>html5中的worker对象，是开辟了一条属于自己的线程，叫专用线程，也可以通过worker对象开辟一条共享线程，<br>开辟的线程时，在同一时间，两条 线程上的东西，同时在运行，A线程可以把结束返回给B线程，B线程也可以把结果抛给A线程，这样性能就提升了，不用一个一个挨着等待了。</p>
]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[js正则捕获型分组与可选捕获型分组]]></title>
    <link href="http://pleasureswx123.github.io/2015/01/29/%E6%AD%A3%E5%88%99%E5%8F%AF%E9%80%89%E9%9D%9E%E6%8D%95%E8%8E%B7%E5%9E%8B%E5%88%86%E7%BB%84/"/>
    <id>http://pleasureswx123.github.io/2015/01/29/正则可选非捕获型分组/</id>
    <published>2015-01-29T05:40:17.000Z</published>
    <updated>2015-02-02T03:34:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="js正则捕获型分组与可选捕获型分组：">js正则捕获型分组与可选捕获型分组：</h3>
<blockquote>
<p>()表示一个捕获型分组<br>(?:…..)表示一个非捕获型分组<br>(?:…..)?表示一个可选的非捕获型分组</p>
</blockquote>
<pre><code><span class="keyword">var</span> parse_url = <span class="regexp">/^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/</span>;
<span class="keyword">var</span> url = <span class="string">'http://www.ora.com:80/goodparts?q#fragment'</span>;
<span class="keyword">var</span> result = parse_url.exec(url);
<span class="keyword">var</span> names = [<span class="string">'url'</span>,<span class="string">'scheme'</span>,<span class="string">'slash'</span>,<span class="string">'host'</span>,<span class="string">'port'</span>,<span class="string">'path'</span>,<span class="string">'query'</span>,<span class="string">'hash'</span>];
<span class="keyword">var</span> blanks = <span class="string">'                  '</span>;
<span class="keyword">var</span> i;
<span class="keyword">for</span>(i=<span class="number">0</span>,l=names.length;i&lt;l;i+=<span class="number">1</span>){
    <span class="keyword">var</span> str = names[i] + <span class="string">':'</span> + blanks.substring(names[i].length) + result[i];
    <span class="built_in">console</span>.log(str);
}

<span class="keyword">var</span> parse_url = <span class="regexp">/^     (?:([A-Za-z]+):)?      (\/{0,3})   ([0-9.\-A-Za-z]+)      (?::(\d+))?        (?:\/([^?#]*))?       (?:\?([^#]*))?      (?:#(.*))?       $/</span>   ;
<span class="keyword">var</span> parse_number = <span class="regexp">/^   -?   \d+   (?:\.\d*)?   (?:e[+\-]?\d+)?   $/i</span>;
</code></pre>]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[js观察者模式]]></title>
    <link href="http://pleasureswx123.github.io/2015/01/28/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://pleasureswx123.github.io/2015/01/28/观察者模式/</id>
    <published>2015-01-28T05:40:17.000Z</published>
    <updated>2015-02-02T03:34:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="js观察者模式：">js观察者模式：</h3>
<pre><code><span class="keyword">var</span> publisher = {
    subscribers:{
        any:[]
    },
    subscribe:<span class="function"><span class="keyword">function</span><span class="params">(fn,type)</span></span>{
        type = type || <span class="string">'any'</span>;
        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.subscribers[type] === <span class="string">'undefined'</span>){
            <span class="keyword">this</span>.subscribers[type] = [];
        }
        <span class="keyword">this</span>.subscribers[type].push(fn);
    },
    unsubscribe:<span class="function"><span class="keyword">function</span><span class="params">(fn,type)</span></span>{
        <span class="keyword">this</span>.visitSubscribers(<span class="string">'unsubscribe'</span>,fn,type);
    },
    publish:<span class="function"><span class="keyword">function</span><span class="params">(publication,type)</span></span>{
        <span class="keyword">this</span>.visitSubscribers(<span class="string">'publish'</span>,publication,type);
    },
    visitSubscribers:<span class="function"><span class="keyword">function</span><span class="params">(action,arg,type)</span></span>{
        <span class="keyword">var</span> pubtype = type || <span class="string">'any'</span>,
            subscribers = <span class="keyword">this</span>.subscribers[pubtype],
            i,
            max = subscribers.length;
        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;max;i+=<span class="number">1</span>){
            <span class="keyword">if</span>(action === <span class="string">'publish'</span>){
                subscribers[i](arg);
            }<span class="keyword">else</span>{
                <span class="keyword">if</span>(subscribers[i]===arg){
                    subscribers.splice(i,<span class="number">1</span>);
                }
            }
        }
    }
};
<span class="function"><span class="keyword">function</span> <span class="title">makePublisher</span><span class="params">(o)</span></span>{
    <span class="keyword">var</span> i;
    <span class="keyword">for</span>(i <span class="keyword">in</span> publisher){
        <span class="keyword">if</span>(publisher.hasOwnProperty(i) &amp;&amp; <span class="keyword">typeof</span> publisher[i] === <span class="string">'function'</span>){
            o[i] = publisher[i];
        }
    }
    o.subscribers = {any:[]};
}
<span class="keyword">var</span> paper = {
    daily:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">this</span>.publish(<span class="string">'big news today'</span>);
    },
    monthly:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">this</span>.publish(<span class="string">'interesting analysis'</span>,<span class="string">'monthly'</span>);
    }
};
makePublisher(paper);
<span class="keyword">var</span> joe = {
    drinkCoffee:<span class="function"><span class="keyword">function</span><span class="params">(paper)</span></span>{
        <span class="built_in">console</span>.log(<span class="string">'Just read'</span> + paper);
    },
    sundayPreNap:<span class="function"><span class="keyword">function</span><span class="params">(monthly)</span></span>{
        <span class="built_in">console</span>.log(<span class="string">'About to fall asleep reading this '</span> + monthly);
    }
};
paper.daily();
paper.daily();
paper.daily();
paper.monthly();
makePublisher(joe);
joe.tweet = <span class="function"><span class="keyword">function</span><span class="params">(msg)</span></span>{
    <span class="keyword">this</span>.publish(msg);
};
paper.readTweets = <span class="function"><span class="keyword">function</span><span class="params">(tweet)</span></span>{
    alert(<span class="string">'Call big meeting! Someone '</span> + tweet);
};
joe.subscribe(paper.readTweets);
joe.tweet(<span class="string">'hated the paper today'</span>);

<span class="keyword">var</span> publisher = {
    subscribers:{
        any:[]
    },
    on:<span class="function"><span class="keyword">function</span><span class="params">(type,fn,context)</span></span>{
        type = type || <span class="string">'any'</span>;
        fn = <span class="keyword">typeof</span> fn === <span class="string">'function'</span> ? fn : context[fn];
        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.subscribers[type] === <span class="string">'undefined'</span>){
            <span class="keyword">this</span>.subscribers[type] = [];
        }
        <span class="keyword">this</span>.subscribers[type].push({
            fn:fn,
            context:context || <span class="keyword">this</span>
        })
    },
    remove:<span class="function"><span class="keyword">function</span><span class="params">(type,fn,context)</span></span>{
        <span class="keyword">this</span>.visitSubscribers(<span class="string">'unsubscribe'</span>,type,fn,context);
    },
    fire:<span class="function"><span class="keyword">function</span><span class="params">(type,publication)</span></span>{
        <span class="keyword">this</span>.visitSubscribers(<span class="string">'publish'</span>,type,publication);
    },
    visitSubscribers:<span class="function"><span class="keyword">function</span><span class="params">(action,type,arg,context)</span></span>{
        <span class="keyword">var</span> pubtype = type || <span class="string">'any'</span>,
            subscribers = <span class="keyword">this</span>.subscribers[pubtype],
            i,
            max=subscribers ? subscribers.length : <span class="number">0</span>;
        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;max;i+=<span class="number">1</span>){
            <span class="keyword">if</span>(action === <span class="string">'publish'</span>){
                subscribers[i].fn.call(subscribers[i].context,arg);
            }<span class="keyword">else</span>{
                <span class="keyword">if</span>(subscribers[i].fn === arg &amp;&amp; subscribers[i].context === context){
                    subscribers.splice(i,<span class="number">1</span>);
                }
            }
        }
    }
};
<span class="function"><span class="keyword">function</span> <span class="title">Player</span><span class="params">(name,key)</span></span>{
    <span class="keyword">this</span>.points = <span class="number">0</span>;
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.key = key;
    <span class="keyword">this</span>.fire(<span class="string">'newplayer'</span>,<span class="keyword">this</span>);
}
Player.prototype.play = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">this</span>.points += <span class="number">1</span>;
    <span class="keyword">this</span>.fire(<span class="string">'play'</span>,<span class="keyword">this</span>);
};
<span class="keyword">var</span> game = {
    keys:{},
    addPlayer:<span class="function"><span class="keyword">function</span><span class="params">(player)</span></span>{
        <span class="keyword">var</span> key = player.key.toString().charCodeAt(<span class="number">0</span>);
        <span class="keyword">this</span>.keys[key] = player;
    },
    handleKeypress:<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>{
        e = e || <span class="built_in">window</span>.event;
        <span class="keyword">if</span>(game.keys[e.which]){
            game.keys[e.which].play();
        }
    },
    handlePlay:<span class="function"><span class="keyword">function</span><span class="params">(player)</span></span>{
        <span class="keyword">var</span> i,
            players = <span class="keyword">this</span>.keys,
            score = {};
        <span class="keyword">for</span>(i <span class="keyword">in</span> player){
            <span class="keyword">if</span>(players.hasOwnProperty(i)){
                score[players[i].name] = players[i].points;
            }
            <span class="keyword">this</span>.fire(<span class="string">'scorechange'</span>,score);
        }
    }
};
makePublisher(Player.prototype);
makePublisher(game);
Player.prototype.on(<span class="string">'newplayer'</span>,<span class="string">'addPlayer'</span>,game);
Player.prototype.on(<span class="string">'play'</span>,<span class="string">'handlePlay'</span>,game);
game.on(<span class="string">'scorechange'</span>,scoreboard.update,scoreboard);
<span class="built_in">window</span>.onkeypress = game.handleKeypress;
<span class="keyword">var</span> playername,key;
<span class="keyword">while</span>(<span class="number">1</span>){
    playername = prompt(<span class="string">'Add player (name)'</span>);
    <span class="keyword">if</span>(!playername){
        <span class="keyword">break</span>;
    }
    <span class="keyword">while</span>(<span class="number">1</span>){
        key = prompt(<span class="string">'Key for '</span> + playername + <span class="string">'?'</span>);
        <span class="keyword">if</span>(key){
            <span class="keyword">break</span>;
        }
    }
    <span class="keyword">new</span> Player(playername,key);
}
</code></pre>]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[js代理模式与中介模式]]></title>
    <link href="http://pleasureswx123.github.io/2015/01/27/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://pleasureswx123.github.io/2015/01/27/代理模式与中介模式/</id>
    <published>2015-01-27T05:40:17.000Z</published>
    <updated>2015-01-30T04:04:14.000Z</updated>
    <content type="html"><![CDATA[<h3 id="js代理模式：">js代理模式：</h3>
<p><img src="/img/mode/mode7.png" alt="Alt text"></p>
<pre><code><span class="keyword">var</span> proxy = {
    ids:[],
    delay:<span class="number">50</span>,
    timeout:<span class="literal">null</span>,
    <span class="keyword">callback</span>:<span class="literal">null</span>,
    context:<span class="literal">null</span>,
    makeRequest:<span class="function"><span class="keyword">function</span><span class="params">(id,callback,context)</span></span>{
        <span class="keyword">this</span>.ids.push(id);
        <span class="keyword">this</span>.<span class="keyword">callback</span> = <span class="keyword">callback</span>;
        <span class="keyword">this</span>.context = context;
        <span class="keyword">if</span>(!<span class="keyword">this</span>.timeout){
            <span class="keyword">this</span>.timeout = setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
                proxy.flush();
            },<span class="keyword">this</span>.delay);
        }
    },
    flush:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        http.makeRequest(<span class="keyword">this</span>.ids,<span class="string">'proxy.handler'</span>);
        <span class="keyword">this</span>.timeout = <span class="literal">null</span>;
        <span class="keyword">this</span>.ids = [];
    },
    handler:<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{
        <span class="keyword">var</span> i,max;
        <span class="keyword">if</span>(parseInt(data.query.count,<span class="number">10</span>)===<span class="number">1</span>){
            proxy.<span class="keyword">callback</span>.call(proxy.context,data.query.results.Video);
            <span class="keyword">return</span>;
        }
        <span class="keyword">for</span>(i=<span class="number">0</span>,max=data.query.results.Video.length;i&lt;max;i+=<span class="number">1</span>){
            proxy.<span class="keyword">callback</span>.call(proxy.context,data.query.results.Video[i]);
        }
    }
};
<span class="keyword">var</span> http = {
    makeRequest:<span class="function"><span class="keyword">function</span><span class="params">(ids,callback)</span></span>{
        <span class="keyword">var</span> url = <span class="string">'http://query.yahooapis.com/v1/public/yql?q='</span>,
            sql = <span class="string">'select * from music.video.id where ids IN ("%ID%")'</span>,
            format = <span class="string">'format=json'</span>,
            handler = <span class="string">'callback='</span> + <span class="keyword">callback</span>,
            script = document.createElement(<span class="string">"script"</span>);
        sql = sql.replace(<span class="string">'%ID%'</span>,ids.join(<span class="string">'","'</span>));
        sql = encodeURIComponent(sql);
        url += sql + <span class="string">'&amp;'</span> + format + <span class="string">'&amp;'</span> + handler;
        script.src = url;
        document.body.appendChild(script);
    }
};
<span class="keyword">var</span> videos = {
    getPlays :<span class="function"><span class="keyword">function</span><span class="params">(id)</span></span>{},
    updataList:<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{},
    getInfo:<span class="function"><span class="keyword">function</span><span class="params">(id)</span></span>{
        <span class="keyword">var</span> info = $(<span class="string">'info'</span>+id);
        <span class="keyword">if</span>(!info){
            http.makeRequest([id],<span class="string">'videos.updataList'</span>);
            <span class="keyword">return</span>;
        }
        <span class="keyword">if</span>(info.style.display===<span class="string">'none'</span>){
            info.style.display = <span class="string">''</span>;
        }<span class="keyword">else</span>{
            info.style.display = <span class="string">'none'</span>;
        }
    }
};

proxy.makeRequest(id,videos.updataList,videos);
</code></pre><h3 id="js中介模式：">js中介模式：</h3>
<p><img src="/img/mode/mode8.png" alt="Alt text"></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Player</span><span class="params">(name)</span></span>{
    <span class="keyword">this</span>.points = <span class="number">0</span>;
    <span class="keyword">this</span>.name = name;
}
Player.prototype.play = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">this</span>.points += <span class="number">1</span>;
    mediator.played();
};
<span class="keyword">var</span> scoreboard = {
    element:<span class="built_in">document</span>.getElementById(<span class="string">'results'</span>),
    update:<span class="function"><span class="keyword">function</span><span class="params">(score)</span></span>{
        <span class="keyword">var</span> i,msg = <span class="string">''</span>;
        <span class="keyword">for</span>(i <span class="keyword">in</span> score){
            <span class="keyword">if</span>(score.hasOwnProperty(i)){
                msg += <span class="string">'&lt;p&gt;&lt;strong&gt;'</span>+i+<span class="string">'&lt;/strong&gt;:'</span>+score[i]+<span class="string">'&lt;/p&gt;'</span>;
            }
        }
        <span class="keyword">this</span>.element.innerHTML = msg;
    }
};
<span class="keyword">var</span> mediator = {
    players:{},
    setup:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">var</span> players = <span class="keyword">this</span>.players;
        players.home = <span class="keyword">new</span> Player(<span class="string">'Home'</span>);
        players.guest = <span class="keyword">new</span> Player(<span class="string">'Guest'</span>);
    },
    played:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">var</span> players = <span class="keyword">this</span>.players,
            score = {
                Home:players.home.points,
                Guest:players.guest.points
            };
        scoreboard.update(score);
    },
    keypress:<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>{
        e = e || <span class="built_in">window</span>.event;
        <span class="keyword">if</span>(e.which === <span class="number">49</span>){
            mediator.players.home.play();
            <span class="keyword">return</span>;
        }
        <span class="keyword">if</span>(e.which === <span class="number">48</span>){
            mediator.players.guest.play();
            <span class="keyword">return</span>;
        }
    }
};
mediator.setup();
<span class="built_in">window</span>.onkeypress = mediator.keypress;
setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="built_in">window</span>.onkeypress = <span class="literal">null</span>;
    alert(<span class="string">'Game over!'</span>);
},<span class="number">30000</span>);
</code></pre>]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[js策略模式]]></title>
    <link href="http://pleasureswx123.github.io/2015/01/26/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://pleasureswx123.github.io/2015/01/26/策略模式/</id>
    <published>2015-01-26T05:40:17.000Z</published>
    <updated>2015-01-29T05:53:46.000Z</updated>
    <content type="html"><![CDATA[<h3 id="js策略模式：">js策略模式：</h3>
<p><img src="/img/mode/mode6.png" alt="Alt text"></p>
<pre><code><span class="keyword">var</span> validator = {
    types: {
        isNonEmpty: {
            validate: <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> </span>{
                <span class="keyword">return</span> value !== <span class="string">''</span>;
            },
            instructions: <span class="string">'不能为空'</span>
        },
        isNumber: {
            validate: <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> </span>{
                <span class="keyword">return</span> !<span class="built_in">isNaN</span>(value);
            },
            instructions: <span class="string">'只能为数字'</span>
        },
        isAlphaNum: {
            validate: <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> </span>{
                <span class="keyword">return</span> !<span class="regexp">/[^a-z0-9]/i</span>.test(value);
            },
            instructions: <span class="string">'只能为数字与字母的集合，不能包含特殊字符'</span>
        }
    },
    messages:[],
    validate:<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{
        <span class="keyword">var</span> i,msg,type,checker,result_ok;
        <span class="keyword">this</span>.messages = [];
        <span class="keyword">for</span>(i <span class="keyword">in</span> data){
            <span class="keyword">if</span>(data.hasOwnProperty(i)){
                type = <span class="keyword">this</span>.config[i];
                checker = <span class="keyword">this</span>.types[type];
                <span class="keyword">if</span>(!type){
                    <span class="keyword">continue</span>; <span class="comment">//不需要验证，比如last_name,然后进行下一次的循环</span>
                }
                <span class="keyword">if</span>(!checker){
                    <span class="keyword">throw</span>  {
                        name:<span class="string">'ValideationError'</span>,
                        message : <span class="string">'缺少验证方法:'</span> + type
                    }
                }
                result_ok = checker.validate(data[i]);
                <span class="keyword">if</span>(!result_ok){
                    msg = <span class="string">'数据'</span>+i+<span class="string">'验证不通过，原因为：'</span>+checker.instructions;
                    <span class="keyword">this</span>.messages.push(msg);
                }
            }
        }
        <span class="keyword">return</span> <span class="keyword">this</span>.hasErrors();
    },
    hasErrors:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">this</span>.messages.length !== <span class="number">0</span>;
    }
};

<span class="keyword">var</span> data = {
    first_name: <span class="string">'Super'</span>,
    last_name: <span class="string">"Man"</span>,
    age: <span class="string">"unknown"</span>,
    username: <span class="string">"o_O"</span>
};
validator.config = {
    first_name: <span class="string">'isNonEmpty'</span>,
    age: <span class="string">'isNumber'</span>,
    username: <span class="string">'isAlphaNum'</span>
};
validator.validate(data);
</code></pre>]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[js装饰者模式]]></title>
    <link href="http://pleasureswx123.github.io/2015/01/25/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://pleasureswx123.github.io/2015/01/25/装饰者模式/</id>
    <published>2015-01-25T06:40:17.000Z</published>
    <updated>2015-01-29T04:08:48.000Z</updated>
    <content type="html"><![CDATA[<h3 id="js装饰者模式：">js装饰者模式：</h3>
<p>装饰者对象都将以构造函数的属性这种方式来实现</p>
<p><img src="/img/mode/mode4.png" alt="Alt text"></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Sale</span><span class="params">(price)</span></span>{
    <span class="keyword">this</span>.price = price || <span class="number">100</span>;
}
Sale.prototype.getPrice = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.price;
};
Sale.decorators =  {
    fedtax : {
        getPrice:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            <span class="keyword">var</span> price = <span class="keyword">this</span>.uber.getPrice();
            price += price * <span class="number">5</span> / <span class="number">100</span>;
            <span class="keyword">return</span> price;
        }
    },
    quebec : {
        getPrice : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            <span class="keyword">var</span> price = <span class="keyword">this</span>.uber.getPrice();
            price += price * <span class="number">7.5</span> / <span class="number">100</span>;
            <span class="keyword">return</span> price;
        }
    },
    money : {
        getPrice : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            <span class="keyword">return</span> <span class="string">'$'</span> + <span class="keyword">this</span>.uber.getPrice().toFixed(<span class="number">2</span>);
        }
    },
    cdn : {
        getPrice : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            <span class="keyword">return</span> <span class="string">'CDN$ '</span> + <span class="keyword">this</span>.uber.getPrice().toFixed(<span class="number">2</span>);
        }
    }
};
Sale.prototype.decorate = <span class="function"><span class="keyword">function</span><span class="params">(decorator)</span></span>{
    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{},
        overrides = <span class="keyword">this</span>.constructor.decorators[decorator],
        i,newobj;
    <span class="built_in">console</span>.log(<span class="keyword">this</span>);
    F.prototype = <span class="keyword">this</span>;  <span class="comment">//除了第一次，每一次this的值都上一次的一个构造函数F的实例</span>
    newobj = <span class="keyword">new</span> F();
    newobj.uber = F.prototype;
    <span class="keyword">for</span>(i <span class="keyword">in</span> overrides){
        <span class="keyword">if</span>(overrides.hasOwnProperty(i)){
            newobj[i] = overrides[i];
        }
    }
    <span class="keyword">return</span> newobj;
};
<span class="keyword">var</span> sale = <span class="keyword">new</span> Sale(<span class="number">100</span>);
sale = sale.decorate(<span class="string">'fedtax'</span>);
sale = sale.decorate(<span class="string">'quebec'</span>);
<span class="comment">//sale = sale.decorate('money');</span>
sale = sale.decorate(<span class="string">'cdn'</span>);
sale.getPrice();  <span class="comment">//先找到cdn的getPrice方法，依次再找this.uber.getPrice()，直到Sale.prototype.getPrice的方法，再从最内到往逐个运行</span>
</code></pre><p>下面是最后newobj的原型结构</p>
<pre><code>newobj: F
getPrice: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>{
    <span class="built_in">arguments</span>: <span class="literal">null</span>
    caller: <span class="literal">null</span>
    length: <span class="number">0</span>
    name: <span class="string">""</span>
    prototype: Sale.decorators.cdn.getPrice        <span class="comment">//cdn</span>
    __proto__: <span class="function"><span class="keyword">function</span> <span class="title">Empty</span><span class="params">()</span> </span>{}
    &lt;<span class="function"><span class="keyword">function</span> <span class="title">scope</span>&gt;
    <span class="title">uber</span>: <span class="title">F</span>
    <span class="title">__proto__</span>: <span class="title">F</span>
    <span class="title">getPrice</span>: <span class="title">function</span> <span class="params">()</span></span>{
        <span class="built_in">arguments</span>: <span class="literal">null</span>
        caller: <span class="literal">null</span>
        length: <span class="number">0</span>
        name: <span class="string">""</span>
        prototype: Sale.decorators.quebec.getPrice     <span class="comment">//quebec</span>
        constructor: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>{
        __proto__: <span class="built_in">Object</span>
        __proto__: <span class="function"><span class="keyword">function</span> <span class="title">Empty</span><span class="params">()</span> </span>{}
        &lt;<span class="function"><span class="keyword">function</span> <span class="title">scope</span>&gt;
        <span class="title">uber</span>: <span class="title">F</span>
        <span class="title">__proto__</span>: <span class="title">F</span>
        <span class="title">getPrice</span>: <span class="title">function</span> <span class="params">()</span></span>{
            <span class="built_in">arguments</span>: <span class="literal">null</span>
            caller: <span class="literal">null</span>
            length: <span class="number">0</span>
            name: <span class="string">""</span>
            prototype: Sale.decorators.fedtax.getPrice      <span class="comment">//fedtax</span>
            __proto__: <span class="function"><span class="keyword">function</span> <span class="title">Empty</span><span class="params">()</span> </span>{}
            &lt;<span class="function"><span class="keyword">function</span> <span class="title">scope</span>&gt;
            <span class="title">uber</span>: <span class="title">Sale</span>
            <span class="title">__proto__</span>: <span class="title">Sale</span>
            <span class="title">price</span>: 100
            <span class="title">__proto__</span>: <span class="title">Sale</span>          //<span class="title">Sale</span>.<span class="title">prototype</span>.<span class="title">getPrice</span>
            <span class="title">constructor</span>: <span class="title">function</span> <span class="title">Sale</span><span class="params">(price)</span></span>{
            decorate: <span class="function"><span class="keyword">function</span> <span class="params">(decorator)</span></span>{
            getPrice: <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>{
            __proto__: <span class="built_in">Object</span>
</code></pre><p>还有一种使用列表来实现，这种方法更为简单，也不涉及继承，也更易于理解</p>
<p><img src="/img/mode/mode5.png" alt="Alt text"></p>
<pre><code><span class="keyword">var</span> Sale = <span class="function"><span class="keyword">function</span> <span class="params">(price)</span></span>{
    <span class="keyword">this</span>.price = (price &gt; <span class="number">0</span> ) || <span class="number">100</span>;  <span class="comment">//this.price为true的时候，在运算当中会作为1来处理，如果为false的时候，在参与参与去处的过程当中会作为0来处理</span>
    <span class="keyword">this</span>.decorators_list = [];
};
Sale.prototype.decorate = <span class="function"><span class="keyword">function</span><span class="params">(decorator)</span></span>{
    <span class="keyword">this</span>.decorators_list.push(decorator);
};
Sale.prototype.getPrice = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> price = <span class="keyword">this</span>.price, i,
        max = <span class="keyword">this</span>.decorators_list.length,name;
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;max;i++){
        name = <span class="keyword">this</span>.decorators_list[i];
        price = Sale.decorators[name].getPrice(price);
    }
    <span class="keyword">return</span> price;
};
Sale.decorators = {
    fedtax : {
        getPrice : <span class="function"><span class="keyword">function</span><span class="params">(price)</span></span>{
            <span class="keyword">return</span> price + price * <span class="number">5</span> / <span class="number">100</span>;
        }
    },
    quebec : {
        getPrice : <span class="function"><span class="keyword">function</span><span class="params">(price)</span> </span>{
            <span class="keyword">return</span> price + price * <span class="number">7.5</span> / <span class="number">100</span>;
        }
    },
    money :{
        getPrice : <span class="function"><span class="keyword">function</span><span class="params">(price)</span></span>{
            <span class="keyword">return</span> <span class="string">'$'</span> + price.toFixed(<span class="number">2</span>);
        }
    }
};
<span class="keyword">var</span> sale = <span class="keyword">new</span> Sale(<span class="number">100</span>);
sale.decorate(<span class="string">'fedtax'</span>);
sale.decorate(<span class="string">'quebec'</span>);
sale.decorate(<span class="string">'money'</span>);
sale.getPrice();
</code></pre>]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[js工厂模式与迭代器模式]]></title>
    <link href="http://pleasureswx123.github.io/2015/01/24/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://pleasureswx123.github.io/2015/01/24/工厂模式与迭代器模式/</id>
    <published>2015-01-24T03:05:16.000Z</published>
    <updated>2015-01-28T11:22:15.000Z</updated>
    <content type="html"><![CDATA[<h3 id="js工厂模式：">js工厂模式：</h3>
<ul>
<li>设计工厂模式的目的是为了创建对象</li>
<li>它通常在类或者类的静态方法中实现</li>
</ul>
<p><img src="/img/mode/mode2.png" alt="Alt text"></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">CarMaker</span><span class="params">()</span></span>{}
CarMaker.prototype.drive = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">return</span> <span class="string">"Vroom,I have "</span>+<span class="keyword">this</span>.doors+<span class="string">" doors"</span>;
};
CarMaker.factory = <span class="function"><span class="keyword">function</span><span class="params">(type)</span></span>{
    <span class="keyword">var</span> constr = type,newcar;
    <span class="keyword">if</span>(<span class="keyword">typeof</span> CarMaker[constr] !== <span class="string">"function"</span>){
        <span class="keyword">throw</span> {
            name:<span class="string">"Error"</span>,
            message:constr+<span class="string">" doesn't exist"</span>
        }
    }
    <span class="keyword">if</span>(<span class="keyword">typeof</span> CarMaker[constr].prototype.drive !== <span class="string">'function'</span>){
        CarMaker[constr].prototype = <span class="keyword">new</span> CarMaker();
    }
    newcar = <span class="keyword">new</span> CarMaker[constr];
    <span class="keyword">return</span> newcar;
};
CarMaker.Compact = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">this</span>.doors = <span class="number">4</span>;
};
CarMaker.Convertible = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">this</span>.doors = <span class="number">2</span>;
};
CarMaker.SUV = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">this</span>.doors = <span class="number">24</span>;
};
</code></pre><p>总结：该工厂模式是通过构造函数自身的静态方法factory，为该构造函数的其它的静态方法创建实例，创建的这些实例的原型是继承自本身的构造函数（new CarMaker()）。</p>
<h3 id="js迭代器模式：">js迭代器模式：</h3>
<blockquote>
<p>  在迭代器模式中，通常有一个包含数据集合的对象。<br>  该数据可能存储在一个复杂数据结构内部，而要提供一种简单的方法能够访问数据结构中每个元素。</p>
</blockquote>
<p><img src="/img/mode/mode3.png" alt="Alt text"></p>
<pre><code><span class="keyword">var</span> agg = (<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> index = <span class="number">1</span>,
        data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],
        lenght = data.length,
        direction,
        symbol;
    <span class="keyword">return</span> {
        nextPrev:<span class="function"><span class="keyword">function</span><span class="params">(opt)</span></span>{
            direction = opt.direction || <span class="string">''</span>;

            <span class="keyword">if</span>(!<span class="keyword">this</span>.hasNext() || !direction){
                <span class="keyword">return</span> <span class="literal">null</span>;
            }
            <span class="comment">//执行动作</span>
            index = <span class="built_in">eval</span>(index+symbol+<span class="number">1</span>);
        },
        hasNext:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            <span class="keyword">if</span>(direction==<span class="string">'next'</span>){
                symbol = <span class="string">'+'</span>;
                <span class="keyword">return</span> index &lt; lenght;
            }
            <span class="keyword">if</span>(direction==<span class="string">'prev'</span>){
                symbol = <span class="string">'-'</span>;
                <span class="keyword">return</span> index &gt; <span class="number">1</span>;
            }
        },
        current:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            <span class="keyword">return</span> index;
        },
        rewind:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
            index = <span class="number">0</span>;
        }
    }
})();

agg.nextPrev({direction:<span class="string">'next'</span>});
agg.nextPrev({direction:<span class="string">'prev'</span>});
agg.current();
agg.rewind();
</code></pre>]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[js单例模式]]></title>
    <link href="http://pleasureswx123.github.io/2015/01/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://pleasureswx123.github.io/2015/01/22/单例模式/</id>
    <published>2015-01-22T06:40:17.000Z</published>
    <updated>2015-01-28T10:30:56.000Z</updated>
    <content type="html"><![CDATA[<h3 id="js单例模式：">js单例模式：</h3>
<p>在看js模式147页实现单例模式的一种方式，纠结出来的问题，记录一下</p>
<p><img src="/img/mode/return.png" alt="Alt text"></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">()</span></span>{
    <span class="keyword">this</span>.name = <span class="string">'testA'</span>;
    <span class="keyword">return</span> <span class="string">'string'</span>;  <span class="comment">//返回的是基本值类型，字符串或数字或布尔或undefined</span>
}
A.prototype.m = <span class="string">'A原型值或方法'</span>;
<span class="keyword">var</span> a = <span class="keyword">new</span> A();
<span class="built_in">console</span>.log(a);  <span class="comment">//实例对象a具有构造函数A原型上的方法</span>


<span class="function"><span class="keyword">function</span> <span class="title">B</span><span class="params">()</span></span>{
    <span class="keyword">this</span>.name = <span class="string">'testB'</span>;
    <span class="keyword">return</span> {};  <span class="comment">//返回对象或数组对象或函数对象</span>
}
B.prototype.m = <span class="string">'B1原型值或方法'</span>;
<span class="keyword">var</span> b = <span class="keyword">new</span> B();
<span class="built_in">console</span>.log(b);  <span class="comment">//实例对象b不具有构造函数B原型上的方法</span>


<span class="function"><span class="keyword">function</span> <span class="title">C</span><span class="params">()</span></span>{
    <span class="keyword">this</span>.name = <span class="string">'testC'</span>;
    <span class="keyword">return</span> <span class="keyword">new</span> A();  <span class="comment">//返回实例对象</span>
}
C.prototype.m = <span class="string">'C原型值或方法'</span>;
<span class="keyword">var</span> c = <span class="keyword">new</span> C();
<span class="built_in">console</span>.log(c);  <span class="comment">//实例对象c不具有构造函数C原型上的方法,但具有构造函数A原型上的方法</span>


<span class="function"><span class="keyword">function</span> <span class="title">D</span><span class="params">()</span></span>{
    <span class="keyword">this</span>.name = <span class="string">'testD'</span>;
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{};  <span class="comment">//返回Function实例对象</span>
}
D.prototype.m = <span class="string">'D原型值或方法'</span>;
<span class="keyword">var</span> d = <span class="keyword">new</span> D();
<span class="built_in">console</span>.log(d); <span class="comment">//实例对象d不具有构造函数D原型上的方法，但具有构造函数Function原型上的方法</span>
</code></pre><p>总结return返回的如果是对象类型则具有该返回对象原型上的方法，否则具有自身构造函数上的方法。</p>
<p>消化js模式一书中讲述到的一种实现单例的模式，在147页</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Universe</span><span class="params">()</span></span>{
    <span class="keyword">var</span> instance;
    Universe = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">return</span> instance;
    };
    Universe.prototype = <span class="keyword">this</span>;
    instance = <span class="keyword">new</span> Universe();
    instance.constructor = Universe;
    instance.start_time = <span class="number">0</span>;
    instance.bang = <span class="string">"Big"</span>;
    <span class="keyword">return</span> instance;
}
Universe.prototype.nothing = <span class="literal">true</span>;
<span class="keyword">var</span> uni = <span class="keyword">new</span> Universe();
Universe.prototype.everything = <span class="literal">true</span>;
<span class="keyword">var</span> uni2 = <span class="keyword">new</span> Universe();

uni === uni2  <span class="comment">//true</span>
</code></pre><p>第二种方法直观些，易于理解</p>
<p><img src="/img/mode/mode1.png" alt="Alt text"></p>
<pre><code><span class="keyword">var</span> Universe;
((<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> instance;
    Universe = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">if</span>(instance) {
            <span class="keyword">return</span> instance;
        }
        instance = <span class="keyword">this</span>;
        <span class="keyword">this</span>.start_time = <span class="number">0</span>;
        <span class="keyword">this</span>.bang = <span class="string">"Big"</span>;
    };
})());

Universe.prototype.nothing = <span class="literal">true</span>;
<span class="keyword">var</span> uni = <span class="keyword">new</span> Universe();
Universe.prototype.everything = <span class="literal">true</span>;
<span class="keyword">var</span> uni2 = <span class="keyword">new</span> Universe();

uni === uni2  <span class="comment">//true</span>
</code></pre>]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[cordovaWebBestPractices.ms]]></title>
    <link href="http://pleasureswx123.github.io/2014/09/30/cordovaWebBestPractices-ms/"/>
    <id>http://pleasureswx123.github.io/2014/09/30/cordovaWebBestPractices-ms/</id>
    <published>2014-09-30T04:00:51.000Z</published>
    <updated>2014-10-20T07:19:50.000Z</updated>
    <content type="html"><![CDATA[<p>Quickly start an app using Yeoman, Ionic, AngularJS and PhoneGap</p>
<h1 id="Cordova_+_Web_Best_Practices_v2-0">Cordova + Web Best Practices v2.0</h1>
<h1 id="Android安卓开发环境搭建">Android安卓开发环境搭建</h1>
<h2 id="1、安装JDK">1、安装JDK</h2>
<p>官网下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">jdk下载页</a><br>点击你下载下来的<code>jdk-8u20-windows-i586.exe</code>文件，会先后安装jdk与jre。<br>安装完JDK后配置环境变量</p>
<p>计算机→属性→高级系统设置→高级→环境变量</p>
<blockquote>
<p>   1 系统变量→新建 <code>JAVA_HOME</code> 变量，变量值填写<code>jdk的安装目录</code>（本人是 C:\Program Files\Java\jdk1.8.0_20)<br>   2 系统变量→寻找 <code>Path</code> 变量→编辑，在变量值最后输入 <code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</code>;<br>   3 系统变量→新建 <code>CLASSPATH</code> 变量，变量值填写   <code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</code>（注意最前面有一点）</p>
</blockquote>
<p>系统变量配置完——检验是否配置成功 运行cmd 输入 <code>java -version</code>;<br>显示出版本号则安装成功。</p>
<h2 id="2、安装apache-ant">2、安装apache-ant</h2>
<p>下载<a href="http://ant.apache.org/bindownload.cgi" target="_blank" rel="external">http://ant.apache.org/bindownload.cgi</a>　<br><img src="http://i.imgur.com/7Phif8i.png" alt=""><br>解压到Ｅ盘<br><img src="http://i.imgur.com/2JbkHP0.png" alt=""><br>配置环境变量<br>系统变量：<br>ANT_HOME : E:\apache-ant-1.9.4-bin\apache-ant-1.9.4<br>CLASSPATH : ;%ANT_HOME%\lib;<br>Path : ;%ANT_HOME%\bin;<br>测试是否安装成功，在cmd命令方式下输入：ant -version，出现下面则安装成功：<br><img src="http://i.imgur.com/hCwlnJ2.png" alt=""></p>
<h2 id="3、安装Android_SDK">3、安装Android SDK</h2>
<h3 id="SDK_Manager-exe_安装SDK">SDK Manager.exe 安装SDK</h3>
<ol>
<li><a href="http://developer.android.com/sdk/index.html" target="_blank" rel="external">下载android-sdk_r23.0.2-windows.zip页面</a><br> 打开下载页面，点击<code>VIEW ALL DOWNLOADS AND SIZES</code>，找到<code>android-sdk_rxx.x.x-windows.zip</code></li>
<li>解压到<code>E:\Android\</code></li>
<li><p>运行E:\Android\android-sdk-windows目录下的【SDK Manager.exe】<br> 然后等待更新…(该步骤必须联网，因为SDK安装包需要在线获取)。<br> 在更新的过程中若遇到如下的提示窗口：<br> <img src="http://hiphotos.baidu.com/exp/pic/item/8640bf8b87d6277fbddcd31429381f30e824fc95.jpg" alt=""><br> 则代表更新失败，解决的方法为：<br> 到<code>C:\WINDOWS\system32\drivers\etc</code>目录下，用记事本打开<code>hosts</code>文件，在最后一行添加上<code>74.125.237.1 dl-ssl.google.com</code>，保存【hosts】文件并关闭。<br> 然后关闭Androic SDK Manager软件，再打开一次，即可更新成功。<br> 上述过程需要反复安装，在安装时我费了不时间，你也可以从网上找其它办法直接下载进行安装，可以参考<a href="http://jingyan.baidu.com/article/636f38bb267982d6b84610f0.html" target="_blank" rel="external">android sdk无法更新的解决方法</a></p>
<p> 我安装的内容如下图：<br> <img src="http://i.imgur.com/GTmtJ3h.png" alt=""></p>
<blockquote>
<p>复制 <code>E:\Android\android-sdk-windows</code>下的 tools目录，粘贴到android-sdk-windows下面改名为 tools-copy ,此时在android-sdk-windows 目录下有两个目录 tools 和 tools-copy<br>在tools-copy目录运行 android.bat ，这样就可以正常 update all 了<br>之后，关闭 sdk,<br>在 android-sdk-windows 目录运行 SDK Manager.exe， 就可以了</p>
</blockquote>
</li>
<li>设置环境变量<br> 计算机右键－属性－高级系统设置－高级－环境变量－<br> 用户变量－PATH－<code>E:\Android\android-sdk-windows\tools;E:\Android\android-sdk-windows\platform-tools</code>。<br> <img src="http://i.imgur.com/nNd1A62.png" alt=""></li>
<li>验证SDK是否安装成功<br> 运行android -h命令<br> <img src="http://i.imgur.com/FDnllOq.png" alt=""><br> 运行cmd adb命令，出现下图则安装成功：<br> <img src="http://i.imgur.com/TlpEyoD.png" alt=""></li>
</ol>
<h3 id="AVD_Manager-exe_安装模拟器">AVD Manager.exe 安装模拟器</h3>
<p>创建Android模拟器，进入 android-sdk 目录<code>E:\Android\android-sdk-windows</code>，<br>双击运行 AVD Manager.exe - ‘android virtual devices’ - create 填写内容，<br><img src="http://i.imgur.com/AuY5FTd.png" alt=""><br>如果target或device下拉列表没有内容的话，说明SDK包没有安装完整有缺少，再安装SDK包，重新再来。<br>如果都有的话，填写完整后，点击OK，就创建了一个AVD Name<br><img src="http://i.imgur.com/B2x2l9B.png" alt=""><br>选中AVD_Name，点击 start，出现<br><img src="http://i.imgur.com/hQMy9by.png" alt=""></p>
<p>yeoman安装</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> yo -g</span>
</code></pre><p>详细参考<a href="http://pleasureswx123.github.io/2014/09/11/Yeoman%E5%AE%89%E8%A3%85md/" target="_blank" rel="external">Yeoman安装</a>文章<br>或分解单个安装，仅留参考npm install -g grunt-cli yo bower generator-angular</p>
<p>cordova安装</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> -g cordova</span>
</code></pre><p>在指定的一个文件夹下运行以下命令（我是在Ｅ盘下）</p>
<pre><code>cordova create myBlogProject <span class="keyword">com</span>.example.myBlogProject <span class="string">"myBlog"</span>
</code></pre><p>这样就会在Ｅ盘下建立一个名为<code>myBlogProject</code>的文件夹，引号里的<code>myBlog</code>为你的App名称，也就是要显示在在你手机上名称。</p>
<pre><code><span class="keyword">cd</span> myBlogProject cordova platforms <span class="built_in">add</span> android
cordova run android

<span class="built_in">mkdir</span> yeoman
</code></pre><p>cd yeoman yo webapp<br>cd ../hooks/ mkdir before_prepare<br>在文件夹before_prepare下建立一个名为yeoman_build_copy_script.sh的文件<br>文件的内容为：</p>
<pre><code><span class="shebang">#!/bin/bash
</span>
<span class="built_in">echo</span> <span class="string">"Building Grunt Project."</span>;
<span class="built_in">cd</span> ./yeoman/;
grunt build;

<span class="built_in">cd</span> ../;

<span class="built_in">echo</span> <span class="string">"Deleting files in ./www"</span>;
rm -rf ./www/*;

<span class="built_in">echo</span> <span class="string">"Copying files from ./yeoman/dist to ./www"</span>;
cp -r ./yeoman/dist/* ./www/;
</code></pre><p>./hooks/before_prepare/yeoman_build_copy_script.sh<br>用git-bash执行上面这个文件，liunx命令，cmd不行的。</p>
<p>cordova run android</p>
<h4 id="wamp上安装cordova">wamp上安装cordova</h4>
<pre><code>安装jdk
安装wamp
安装nodejs
cordova <span class="built_in">create</span> hello com.example.hello HelloWorld
安装cordova
C:\&gt;npm install -g cordova<span class="comment"> //安装</span>
在www目录下建立hello文件夹
$ cordova <span class="built_in">create</span> hello com.example.hello HelloWorld<span class="comment"> //创建APP</span>
进入hello
$ cd hello<span class="comment"> //进入APP</span>
<span class="built_in">platform</span> 创建android
cordova <span class="built_in">platform</span> <span class="built_in">add</span> android <span class="comment"> //添加android平台</span>
</code></pre><h4 id="cordova命令：">cordova命令：</h4>
<pre><code>cordova platforms ls<span class="comment"> //查看当前的平台</span>
cordova <span class="built_in">platform</span> rm android<span class="comment"> //删除平台</span>
cordova build<span class="comment"> //生成apk,apk目录在C:\hellocordova\platforms\android\ant-build</span>
cordova emulate android<span class="comment"> //在SDK模拟器上运行</span>
cordova run android<span class="comment"> //直接上手机上进行安装运行。（手机连接到电脑上，设置手机上的开发者模式）</span>
cordova plugin <span class="built_in">add</span> org.apache.cordova.device<span class="comment"> //添加插件</span>
cordova plugin ls<span class="comment"> //查看插件</span>
cordova plugin rm org.apache.cordova.console<span class="comment"> //删除插件</span>
cordova plugin <span class="built_in">add</span> org.apache.cordova.console org.apache.cordova.device<span class="comment"> //添加多个插件</span>
cordova help<span class="comment"> //帮助命令</span>
cordova inf<span class="comment">o//app信息</span>
cordova <span class="built_in">platform</span> update android<span class="comment"> //更新android</span>
</code></pre><p>cordova build命令或cordova run android命令不成功，提示：<br><a href="http://blog.csdn.net/johnnycode/article/details/7678083" target="_blank" rel="external">ADB server didn’t ACK 的解决方法</a><br>    C:>netstat -ano 查看所有进程，查看进程对应的pid<br>    C:>tasklist /fi “pid eq pid值” 或者进入任务管理器，干掉pid的进程<br>干掉这个进程就OK了。</p>
<p>扩展阅读：</p>
<p><a href="https://github.com/yeoman/generator-mobile" target="_blank" rel="external">https://github.com/yeoman/generator-mobile</a><br><a href="http://www.portlandwebworks.com/blog/combining-yeoman-angularjs-and-cordova-mobile-development" target="_blank" rel="external">http://www.portlandwebworks.com/blog/combining-yeoman-angularjs-and-cordova-mobile-development</a><br><a href="https://gauntface.com/blog/2014/02/05/cordova-web-best-practices-v2-0" target="_blank" rel="external">https://gauntface.com/blog/2014/02/05/cordova-web-best-practices-v2-0</a><br><a href="https://gauntface.com/blog/2013/07/18/cordova-web-best-practices/" target="_blank" rel="external">https://gauntface.com/blog/2013/07/18/cordova-web-best-practices/</a><br><a href="http://damien.antipa.at/blog/2014/01/05/build-a-cordova-app-with-angularjs/" target="_blank" rel="external">http://damien.antipa.at/blog/2014/01/05/build-a-cordova-app-with-angularjs/</a></p>
<p><a href="http://blog.csdn.net/offbye/article/details/38223769" target="_blank" rel="external">http://blog.csdn.net/offbye/article/details/38223769</a><br><a href="http://ionicframework.com/getting-started/" target="_blank" rel="external">http://ionicframework.com/getting-started/</a></p>
<p>Cordova + Yeoman<br><a href="http://damien.antipa.at/blog/2014/01/05/build-a-cordova-app-with-angularjs/" target="_blank" rel="external">http://damien.antipa.at/blog/2014/01/05/build-a-cordova-app-with-angularjs/</a><br><a href="http://tiantian-yuqing.iteye.com/blog/2104097" target="_blank" rel="external">http://tiantian-yuqing.iteye.com/blog/2104097</a><br><a href="http://www.numediaweb.com/web-app-with-dream-team/" target="_blank" rel="external">http://www.numediaweb.com/web-app-with-dream-team/</a><br><a href="http://rockyj.in/2013/05/11/yeoman_and_backbone.html" target="_blank" rel="external">http://rockyj.in/2013/05/11/yeoman_and_backbone.html</a><br><a href="https://gauntface.com/blog/2013/07/18/cordova-web-best-practices" target="_blank" rel="external">https://gauntface.com/blog/2013/07/18/cordova-web-best-practices</a><br><a href="https://gauntface.com/blog/2014/02/05/cordova-web-best-practices-v2-0" target="_blank" rel="external">https://gauntface.com/blog/2014/02/05/cordova-web-best-practices-v2-0</a><br><a href="http://blog.mncc.fr/2014/02/10/quickly-start-app-with-yeoman-ionic-angular-and-phonegap/" target="_blank" rel="external">http://blog.mncc.fr/2014/02/10/quickly-start-app-with-yeoman-ionic-angular-and-phonegap/</a></p>
]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[无线页面的一点点小总结.md]]></title>
    <link href="http://pleasureswx123.github.io/2014/09/28/%E6%97%A0%E7%BA%BF%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E5%B0%8F%E6%80%BB%E7%BB%93md/"/>
    <id>http://pleasureswx123.github.io/2014/09/28/无线页面的一点点小总结md/</id>
    <published>2014-09-28T11:18:36.000Z</published>
    <updated>2014-09-29T03:47:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="无线页面的一点点小总结">无线页面的一点点小总结</h1>
<p>总结两个方面：</p>
<ol>
<li>css3</li>
<li>js-iscroll</li>
</ol>
<h2 id="css3">css3</h2>
<p>从几个代表的部分展开分析css3</p>
<ul>
<li>logo部分</li>
<li>top布局部分</li>
<li>图标部分　@font-face</li>
</ul>
<h3 id="logo部分">logo部分</h3>
<pre><code>先说一下<span class="escape">`b</span>ackground-size<span class="escape">`,</span>随带说一下<span class="escape">`b</span>ackground-clip<span class="escape">`与</span><span class="escape">`b</span>ox-sizing`
</code></pre><table>
<thead>
<tr>
<th style="text-align:left">内容</th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">background-size</td>
<td style="text-align:left">background-clip</td>
<td style="text-align:left">background-sizing</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="http://codepen.io/pleasureswx123/pen/vIeox" target="_blank" rel="external">示例demo</a> <code>background-size</code>,<code>background-clip</code>与<code>box-sizing</code></p>
</blockquote>
<pre><code><span class="attribute">background-size</span>: <span class="string">contain | cover | inherit</span>
</code></pre><p><code>contain</code> 等比，完全保留全部的底图，把完整的底图放进去展现出来，可能会留白，可能会铺不完全，以图为基准，只要把完整的图放进去目的就达到了<br>底图等比（放大或缩小）且完整的呈现在box中</p>
<p><img src="http://i.imgur.com/CeKNORi.png" alt=""></p>
<p><code>cover</code> 等比，填满，不留空白，超出的隐藏，把完整的框全部用底图铺满，不会留白，以框为基准，只要把框全部用图覆盖满了就行，不留空白死角<br>box会被底图全部填满，底图同样等比（放大或缩小），但底图超出的部分会被隐藏不显示。</p>
<p><img src="http://i.imgur.com/I30XsEJ.png" alt=""></p>
<p>如果框的大小与底图的大小是等比例的，那么 <code>background-size: contain | cover | 100%</code> ;这时候这三者是一样的效果。</p>
<pre><code>background-clip: border-<span class="keyword">box</span> | padding-<span class="keyword">box</span> | content-<span class="keyword">box</span>  <span class="comment">//从什么位置（边缘）开始填充底图</span>
</code></pre><p><code>border-box</code> 　 从border的外界边缘开始填充底图</p>
<p><img src="http://i.imgur.com/UeOUkVO.png" alt="">    <img src="http://i.imgur.com/8d805bx.png" alt=""></p>
<p><code>padding-box</code> 　从padding的外界边缘开始填充底图</p>
<p><img src="http://i.imgur.com/lwEzRLA.png" alt="">    <img src="http://i.imgur.com/gyn0Lfr.png" alt=""></p>
<p><code>content-box</code> 　从content的外界边缘开始填充底图</p>
<p><img src="http://i.imgur.com/4HGH6MH.png" alt="">    <img src="http://i.imgur.com/Ez92Pi6.png" alt=""></p>
<pre><code><span class="keyword">box</span>-sizing: border-<span class="keyword">box</span> | padding-<span class="keyword">box</span> | content-<span class="keyword">box</span> 盒子的大小，是包含padding呢，border呢，还是content呢
</code></pre><p> <code>border-box</code> 意思是　width = contentWidth + padding + border;<br><img src="http://i.imgur.com/y5VQdLD.png" alt="">   <img src="http://i.imgur.com/HD8SJ2w.png" alt=""></p>
<p> <code>padding-box</code> 意思是 width = contentWidth + padding;　　-webkit-box-sizing: padding-box; -webkit不支持padding-box;</p>
<p><img src="http://i.imgur.com/87NkJDE.png" alt="">  chrome(-webkit) 版本 37.0.2062.120 暂时还不支持padding-box;</p>
<p> <code>content-box</code> 意思是　width = contentWidth;</p>
<p><img src="http://i.imgur.com/5YxLyek.png" alt="">   <img src="http://i.imgur.com/JSazoay.png" alt=""></p>
<h3 id="top布局部分">top布局部分</h3>
<pre><code><span class="label">display:</span> box<span class="comment">;     box-flex: 1;</span>
<span class="escape">`b</span>ox-orient<span class="escape">` </span>    <span class="escape">`b</span>ox-direction<span class="escape">` </span>    <span class="escape">`b</span>ox-pack<span class="escape">` </span>    <span class="escape">`b</span>ox-align`
</code></pre><p> <a href="http://codepen.io/pleasureswx123/pen/gvjhi" target="_blank" rel="external">box &amp;&amp; box-flex</a> <code>box-orient</code> <code>box-direction</code> <code>box-align</code> <code>box-pack</code></p>
<pre><code>`box-orien<span class="variable">t:</span> horizontal | <span class="keyword">vertical</span>`  轴，确定是到底哪个轴，是水平轴还是垂直轴
</code></pre><p><img src="http://i.imgur.com/USCiFL2.png" alt=""></p>
<pre><code><span class="escape">`b</span>ox-direction: normal | reverse<span class="escape">`　</span>轴的方向，是正向还是逆向
</code></pre><p><img src="http://i.imgur.com/WAY6zo0.png" alt=""></p>
<pre><code>`box-pack: <span class="operator"><span class="keyword">start</span> | <span class="keyword">end</span>| center | justify;</span>` 轴上的位置，是居左居右居中还是两端对齐
</code></pre><p>box-pack的方向与box-orient的方向是相同的一致的</p>
<p><img src="http://i.imgur.com/V0lFei8.png" alt=""></p>
<pre><code>`box-align: <span class="operator"><span class="keyword">start</span> | <span class="keyword">end</span> | center | baseline | stretch;</span>` 相反的轴上的位置，是居左居右居中还是两端对齐
</code></pre><p>box-align的方向与box-orient的方向是相反的不一致的</p>
<p><img src="http://i.imgur.com/kKXURkH.png" alt=""></p>
<p>由box-pack与box-align实现居中会很容易，box-pack与box-align的方向受box-orient与box-direction的影响。</p>
<h3 id="图标部分_@font-face">图标部分　@font-face</h3>
<ul>
<li>自己绘制图标字体，参考　<a href="http://pleasureswx123.github.io/2014/09/04/fontfaceIcon/" target="_blank" rel="external">自制矢量图标转换成字体</a>　文章。</li>
<li>由其它网站（如：<a href="https://icomoon.io/" target="_blank" rel="external">icomoon</a>  <a href="http://fortawesome.github.io/Font-Awesome/" target="_blank" rel="external">fortawesome</a>）及其类似的网站，别人制好的库里筛选自己想的图标字体</li>
</ul>
<pre><code><span class="attr_selector">[class^="baikeicon-"]</span>, <span class="attr_selector">[class*=" baikeicon-"]</span> <span class="rules">{
    <span class="rule"><span class="attribute">font-family</span>:<span class="value"> <span class="string">'icomoon'</span></span></span>;
    <span class="rule"><span class="attribute">speak</span>:<span class="value"> none</span></span>;
    <span class="rule"><span class="attribute">font-style</span>:<span class="value"> normal</span></span>;
    <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> normal</span></span>;
    <span class="rule"><span class="attribute">font-variant</span>:<span class="value"> normal</span></span>;
    <span class="rule"><span class="attribute">text-transform</span>:<span class="value"> none</span></span>;
    <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">1</span></span></span>;

    <span class="comment">/* Better Font Rendering =========== */</span>
    <span class="rule"><span class="attribute">-webkit-font-smoothing</span>:<span class="value"> antialiased</span></span>;
    <span class="rule"><span class="attribute">-moz-osx-font-smoothing</span>:<span class="value"> grayscale</span></span>;
<span class="rule">}</span></span>

<span class="class">.baikeicon-home</span><span class="pseudo">:before</span> <span class="rules">{
    <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">"\e60c"</span></span></span>;
<span class="rule">}</span></span>
</code></pre><p>添加class的值，通过伪类:before的content给标签加图标内容，标签对应的字符，如下图（下载下来的demo），可以自己去定义要用的字符。</p>
<p><img src="http://i.imgur.com/c9eOSj0.png" alt=""></p>
<h2 id="iscroll">iscroll</h2>
<p>参考文档：　<a href="http://www.gafish.net/api/iScroll.html" target="_blank" rel="external">iscroll4</a></p>
<p>结束</p>
]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[npm常用的命令.md]]></title>
    <link href="http://pleasureswx123.github.io/2014/09/15/npm%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4md/"/>
    <id>http://pleasureswx123.github.io/2014/09/15/npm常用的命令md/</id>
    <published>2014-09-15T06:19:54.000Z</published>
    <updated>2014-09-29T10:37:35.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nodejs中npm常用命令">nodejs中npm常用命令</h1>
<pre><code>npm install <span class="tag">&lt;<span class="title">name</span>&gt;</span>安装nodejs的依赖包
</code></pre><p>例如<code>npm install express</code> 就会默认安装express的最新版本，也可以通过在后面加版本号的方式安装指定版本，如<code>npm install express@3.0.6</code></p>
<pre><code>npm install &lt;name&gt; -g  <span class="comment">//将包安装到全局环境中</span>
</code></pre><p>但是代码中，直接通过require()的方式是没有办法调用全局安装的包的。全局的安装是供命令行使用的，就好像全局安装了vmarket后，就可以在命令行中直接运行vm命令</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> &lt;name&gt; <span class="comment">--save  //安装的同时，将信息写入package.json中</span></span>
</code></pre><p>项目路径中如果有package.json文件时，直接使用<code>npm install</code>方法就可以根据dependencies配置安装所有的依赖包</p>
<p>这样代码提交到github时，就不用提交node_modules这个文件夹了。</p>
<pre><code>npm init  <span class="comment">//会引导你创建一个package.json文件，包括名称、版本、作者这些信息等</span>

npm remove &lt;name&gt;  <span class="comment">//移除</span>

npm update &lt;name&gt;  <span class="comment">//更新</span>

npm <span class="keyword">ls</span>             <span class="comment">//列出当前安装的了所有包</span>

npm root           <span class="comment">//查看当前包的安装路径</span>

npm root -g        <span class="comment">//查看全局的包的安装路径</span>

npm <span class="keyword">help</span>           <span class="comment">//帮助，如果要单独查看install命令的帮助，可以使用的npm help install</span>

npm config <span class="keyword">ls</span> -l   <span class="comment">//可以查看当前的目录设置</span>

npm cache clean    <span class="comment">//清除缓存命令</span>

npm -g update    <span class="comment">//更新全局</span>
</code></pre>]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[APP的三种开发模式.md]]></title>
    <link href="http://pleasureswx123.github.io/2014/09/15/APP%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8Fmd/"/>
    <id>http://pleasureswx123.github.io/2014/09/15/APP的三种开发模式md/</id>
    <published>2014-09-15T03:19:17.000Z</published>
    <updated>2014-09-15T05:11:26.000Z</updated>
    <content type="html"><![CDATA[<h1 id="APP的三种开发模式">APP的三种开发模式</h1>
<p>开发者们都知道在高端智能手机系统中有两种应用程序：</p>
<ol>
<li>一种是基于本地（操作系统）运行的APP —-Native App；</li>
<li>一种是基于高端机的浏览器运行的App —-WebApp<br> 因为这些高端智能手机（Iphone、Android）的内置浏览器都是基于webkit内核的，所以在开发WEBAPP时，多数都是使用HTML5和CSS3技术做UI布局。当使用HTML5和CSS3l做UI时，若还是遵循着一般web开发中使用HTML4和CSS2那样的开发方式的话，这也就失去了WEBAPP的本质意义了</li>
<li>一种是基于上两种发展出来的产物 —-Hybrid App<br> Hybrid App（混合模式移动应用）是指介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”。</li>
</ol>
<p>移动产品的实现方式主要有三种：</p>
<ol>
<li>Native App；</li>
<li>Web App；</li>
<li>Hybrid App</li>
</ol>
<blockquote>
<p>目前移动互联网基本采用了<code>NativeApp</code>、<code>WebApp</code>、<code>HybridApp</code>三种开发模式，很难说这三种模式那种更优越，目前的情况可以说是三分天下吧，不同的开发者可以根据自己的实际情况选择不同的开发模式。谈论那种模式最好实际上事非常无聊的事情。</p>
</blockquote>
<h3 id="NativeApp指的是本地化应用，就是我们从应用商店下载安装的独立应用">NativeApp指的是本地化应用，就是我们从应用商店下载安装的独立应用</h3>
<ol>
<li>开发成本非常大。<br> 一般使用的开发语言为JAVA、C++、Objective-C。</li>
<li>更新体验较差、同时也比较麻烦<br> 每一次发布新的版本，都需要做版本打包，且需要用户手动更新（有些应用程序即使不需要用户手动更新，但是也需要有一个恶心的提示）。</li>
<li>非常酷<br> 因为native app可以调用IOS中的UI控件以UI方法，它可以实现WebApp无法实现的一些非常酷的交互效果</li>
<li>Native app是被Apple认可的<br> Native app可以被Apple认可为一款可信任的独立软件，可以放在Apple Stroe出售，但是Web app却不行。</li>
</ol>
<p>开发<code>成本过高</code>，<code>跨平台性不好</code>是开发者们选择放弃这种开发模式的重要原因。开发语音主要采用<code>Object-C、Java</code>等语言。由于我不是做<code>Native</code>端开发的，这里不多说了。</p>
<h3 id="WebApp通常是指触屏站，就是我们通过手机浏览器访问的Html5网站，Html5支持一些新标签和脚本，可以做出类原生应用的效果和动画">WebApp通常是指触屏站，就是我们通过手机浏览器访问的Html5网站，Html5支持一些新标签和脚本，可以做出类原生应用的效果和动画</h3>
<ol>
<li>开发成本较低<br> 使用web开发技术就可以轻松的完成web app的开发</li>
<li>升级较简单<br> 升级不需要通知用户，在服务端更新文件即可，用户完全没有感觉</li>
<li>维护比较轻松<br> 和一般的web一样，维护比较简单，它其实就是一个站点</li>
</ol>
<p>Webapp说白了就是一个针对Iphone、Android优化后的web站点，它使用的技术无非就是HTML或HTML5、CSS3、JavaScript，服务端技术JAVA、PHP、ASP。</p>
<p>HTML5技术的兴起给Web App注入了新的生机。<br>Web App具有<code>开发成本低</code>、<code>周期短</code>、<code>使用方便</code>、<code>维护简单</code>等特点。<br>随着HTML5被过度热炒和实际开发中遇到的性能以及体验问题，WebApp逐渐势弱。<br>同样，以<code>AppStore为首的App分发平台当然是不希望webapp破坏自己建立的生态系统的</code>。html5迟迟没有得不到一个公认的标准，也阻碍着webapp的发展。但是这些都不足以阻碍webapp的发展。现在APP的数量已经达到数以百万计，实际上用户根本不需要这么多的App，很多App被用户下载后，一个月都不会被打开一次。<br>而webapp用户根本<code>不需要安装</code>，只需要<code>打开手机浏览器，输入网址或搜索目标</code>，点击即可到达想要的网页，<code>基本和PC互联网的思路是一致的</code>，这也说明百度同样在移动入口上有这很大的优势。在NativeApp上用户只有安装了App，才能浏览，而webapp是直接通过手机浏览器为入口，或者推送的信息为入口，这么看webapp在流量上是有很大的优势的。</p>
<p>但是目前webapp得不到很好的发展主要有以下几个方面的原因：</p>
<ol>
<li>无有效且广泛的webapp发行渠道（NativeApp有AppStore等）；</li>
<li>webapp表现和体验不佳（这点算硬伤吧）；</li>
<li>适配难度（一套web很难兼容所有的手机，特别是国内某些自以为很牛B的手机，大可乐算一个吧，哈哈）；</li>
<li>配套的标准尚未成熟（主要指html5吧）。</li>
</ol>
<p>网站移动化是必然的，目前知道webapp比较好的解决方案有如下几个：</p>
<ol>
<li>云适配  号称引入一段神奇的代码就能将PC网站移动化。陈本峰老师也是我学习的榜样，html5布道官。了解更多信息可以链接到<a href="http://www.yunshipei.com/" target="_blank" rel="external">http://www.yunshipei.com/</a></li>
<li>百度site App  网址：<a href="http://siteapp.baidu.com/" target="_blank" rel="external">http://siteapp.baidu.com/</a></li>
<li>还知道个做微站的网站，号称把微信、微博入口都已打通，企业用户营销很好的平台：<a href="http://www.weizhan360.com/" target="_blank" rel="external">http://www.weizhan360.com/</a></li>
</ol>
<h3 id="HybridApp是指混合模式应用，同时使用网页语言与程序语言编写，包含原生视图和Web视图两种方式，使用方式和Native_App一致，而又继承了Web_App实时更新开发成本低等优点。">HybridApp是指混合模式应用，同时使用网页语言与程序语言编写，包含原生视图和Web视图两种方式，使用方式和Native App一致，而又继承了Web App实时更新开发成本低等优点。</h3>
<p>汽车有混合动力Hybrid，移动应用同样也有混合模式。Hybrid App兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”。很多人不知道市场上一些主流移动应用都是基于Hybrid App的方式开发，比如国外有Facebook、国内有百度搜索等。但究竟什么是Hybrid App？如何定义？</p>
<ul>
<li>mobile application：Hybrid App就是一个移动应用</li>
<li>both browser-supported language and computer language：同时使用网页语言与程序语言编写</li>
<li>available through application distribution platforms：通过应用商店进行分发</li>
<li>a target device：区分目标平台</li>
<li>install to run：用户需要安装使用</li>
</ul>
<p>综合一下就是：“Hybrid App同时使用网页语言与程序语言开发，通过应用商店区分移动操作系统分发，用户需要安装使用的移动应用”。总体特性更接近Native App但是和Web App区别较大。只是因为同时使用了网页语言编码，所以开发成本和难度比Native App要小很多。因此说，Hybrid App兼具了Native App的所有优势，也兼具了Web App使用HTML5跨平台开发低成本的优势。</p>
<p>Hybrid App的兴起是现阶段移动互联网产业的一种偶然。移动互联网的热潮刮起后，众多公司前赴后继的进入。但是很快发现移动应用的开发人员太少，所以导致疯狂的人才争夺。市场机制下移动应用开发人才的待遇扶摇直上，最终变成众多企业无法负担养一个具备跨平台开发能力的专业移动应用开发团队。而HTML5的出现让Web App露出曙光，HTML5开发移动应用的跨平台和廉价优势让众多想进入移动互联网领域的公司开始心动。可是当下基于HTML5的Web App更是雾里看花，在用户入口习惯、分发渠道和应用体验这三个核心问题没解决之前，Web App也很难得以爆发。正是在这样是机缘巧合下，基于HTML5低成本跨平台开发优势又兼具Native App特质的Hybrid App技术杀入混战，并且很快吸引了众人的目光。大幅的降低了移动应用的开发成本，可以通过现有应用商店模式发行，在用户桌面形成独立入口等等这些，让Hybrid App成为解决移动应用开发困境不错的选择，也成为现阶段Web App的代言人。Hybrid App像刺客一样，在Native App和Web App混战之时，偶然间的在移动应用开发领域占有了一席之地。</p>
<p>Hybrid App，这种既有<code>跨平台开发周期短</code>、<code>成本低的基因</code>，又<code>能发挥Native App体验和性能</code>的优势，HybridApp混合式移动应用开发逐渐成为企业移动开发的首选。<br>Hybrid App通常是<code>基于第三方跨平台移动应用引擎框架</code>进行开发，<br>在国内开发者中比较知名的有<code>PhoneGap、Titanium和AppCan这些引擎框架</code>一般使用<code>HTML5和Javascript</code>作为编程语言，调用<code>引擎封装的底层功能如照相机、传感器、通讯录、二维码</code>等。<code>HTML5和Javascript只是作为一种解析语言，真正调用的都是NativeApp一样封装的底层功能，这是和Web App的最大区别和不同</code>。因为使用了<code>浏览器技术</code>，所以Hybrid App通常具有<code>跨平台的特性</code>，并且<code>开发成本和WebApp接近</code>，开发<code>效率也远高于Native App</code>。</p>
<p>说实在的，从表面上看的话，很难区分一个App到底是Native App还是Hybrid App，但实际上我们更多的是把<code>Hybrid App当做是Webapp的一部分</code>，因为他是一部分Native（比较少），绝大部分的web页面（html5页面）。</p>
<p>Hybrid App和Native App一样都是需要用户在各种App分发渠道上<code>下载并安装到手机上才能用的</code>。Hybrid App的体验当然是没话说，比较棒的，有这Native App的全部优点。html5很好的解决了跨平台性的问题，也解决了开发成本过高的问题。</p>
<p>One Web more  native 可以很好的形容Hybrid App这种开发模式。</p>
<p>Hybrid App是如何实现网页语言与程序语言的混合？谁占主体？</p>
<p>Hybrid App通常分为三种类型：<code>多View混合型，单View混合型，Web主体型</code>。</p>
<p><img src="http://images.51cto.com/files/uploadimg/20120628/1602500.jpg" alt=""></p>
<blockquote>
<p>从分析可见，Hybrid App中的Web主体型只要能够解决用户体验差的问题，就可以变成最佳Hybrid App解决方案类型。</p>
</blockquote>
<p>Hybrid App的瓶颈与未来</p>
<p>国内外Hybrid App的开发框架众多。如何选择又成为一个难题。下面对开发者比较关心的集中知名跨平台开发移动应用中间件进行列表和对比，以便选择最适合您的移动应用中间件。</p>
<p><img src="http://d.hiphotos.baidu.com/baike/c0%3Dbaike180%2C5%2C5%2C180%2C60%3Bt%3Dgif/sign=b8a433128c5494ee932f074b4c9c8b9b/d53f8794a4c27d1e996189691bd5ad6edcc438d3.jpg" alt=""></p>
<p>PhoneGap是相对比较早进入公众视线的一种选择。但是，开发者简单的基于PhoneGap来开发移动应用肯定会发现结果和Web App比较差的用户体验类似。这也是为什么基于PhoneGap有实用性的移动应用主要集中在iOS上。可是PhoneGap这种现状弱化了HTML5的跨平台价值。</p>
<p>AppCan在技术架构上和PhoneGap类似是Web主体型中间件，但是通过结合了一些原生交互效果能够达到iOS、Android平台都比较一致的用户体验。但是相比PhoneGap的开源，AppCan相对封闭的路线显得过于谨慎。</p>
<p>Titanium是一种基于翻译机制的跨平台中间件，能够开发出具有Native体验的移动应用，但是因为翻译机制的限制导致移动应用开发不能像真正的HTML5开发一样灵活。哪怕一个按钮也不能像普通HTML一样来编写，而必须按照Titanium约定的特定格式。</p>
<p>Hybrid App这个领域虽然还处于比较初期的阶段，但是已经有很多优秀的公司和技术团队在致力于跨平台开发移动应用中间件技术的研究，给了开发者众多选择。开发者可以根据实际的项目需求来选择中间件。Web App虽被浏览器厂商和搜索引擎公司所推崇，但存在用户体验差、盈利模式不明确等现阶段无法解决的问题，或最终夭折。Hybrid App正在被越来越多的公司和开发者所认同，势必会成为新世界的王。</p>
<p>Web App、Hybrid App、Native APP对比</p>
<table>
<thead>
<tr>
<th>—-</th>
<th>Web App（网页应用）</th>
<th>Hybrid App（混合应用）</th>
<th>Native App（原生应用）</th>
</tr>
</thead>
<tbody>
<tr>
<td>开发成本</td>
<td>低</td>
<td>中</td>
<td>高</td>
</tr>
<tr>
<td>维护更新</td>
<td>简单</td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr>
<td>体验</td>
<td>差</td>
<td>优</td>
<td>优</td>
</tr>
<tr>
<td>Store或market认可</td>
<td>不认可</td>
<td>认可</td>
<td>认可</td>
</tr>
<tr>
<td>安装</td>
<td>不需要</td>
<td>需要</td>
<td>需要</td>
</tr>
<tr>
<td>跨平台</td>
<td>优</td>
<td>优</td>
<td>差</td>
</tr>
</tbody>
</table>
<pre><code>HybridApp开发，现阶段主流的平台包括PhoneGap（Cordova），AppCan，appMobi，Titanium等，它们基于webkit开源内核，使用HTML5 标准开发，适配机型简单，支持开发者自定义插件，并能很好的应用于商业，教育，娱乐等行业，成为移动开发者的首选开发平台。
</code></pre>]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[linux文件结构.md]]></title>
    <link href="http://pleasureswx123.github.io/2014/09/12/linux%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84md/"/>
    <id>http://pleasureswx123.github.io/2014/09/12/linux文件结构md/</id>
    <published>2014-09-12T11:59:42.000Z</published>
    <updated>2014-09-12T12:03:33.000Z</updated>
    <content type="html"><![CDATA[<p>本文内容整理自网络，以作参考。</p>
<p><img src="http://images.cnitblog.com/blog/80780/201306/28142420-0e319099f59243c4a98ca6805c3cbc26.jpg" alt="文件结构"></p>
<h2 id="文件系统的类型">文件系统的类型</h2>
<p>LINUX有四种基本文件系统类型：<code>普通文件、目录文件、连接文件和特别文件</code>，可用file命令来识别。</p>
<pre><code>普通文件：如文本文件、C语言元代码、SHELL脚本、二进制的可执行文件等，可用<span class="keyword">cat</span>、less、more、<span class="keyword">vi</span>、emacs来察看内容，用mv来改名。
目录文件：包括文件名、子目录名及其指针。他是LINUX储存文件名的唯一地方，可用<span class="keyword">ls</span>列出目录文件。
连接文件：是指向同一索引节点的那些目录条目。用<span class="keyword">ls</span>来查看是，连接文件的标志用<span class="keyword">l</span>开头，而文件面后以<span class="string">"-&gt;"</span>指向所连接的文件。
特别文件：LINUX的一些设备如磁盘、终端、打印机等都在文件系统中表示出来，则一类文件就是特别文件，常放在/dev目录内。例如，软驱A称为/dev/fd0。LINUX无C：的概念，而是用/dev/had来自第一硬盘。
</code></pre><h2 id="目录结构的周详解说">目录结构的周详解说</h2>
<pre><code>文件系统的组织结构分析，我们能分析什么呢？也就是当我们列/目录时，所看到的
/usr、/etc <span class="keyword">...</span> <span class="keyword">...</span> /var
等目录是做什么用的，这些目录是不是有些特定的用途。无论哪个哪个版本的Linux系统，都有这些目录，这些目录应该是标准的。当然各个Linux发行版
本也会存在一些小小的差异，但总体来说，大体还是差不多。
言归正传，下面飘扬将讲到本文最核心的部分：linux文件系统的目录结构。
</code></pre><table>
<thead>
<tr>
<th style="text-align:right">目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">/</td>
<td>bLinux文件系统的入口，也是处于最高一级的目录；</td>
</tr>
<tr>
<td style="text-align:right">/bin</td>
<td>系统所需要的那些命令位于此目录，比如 ls、cp、mkdir等命令；功能和/usr/bin类似，这个目录中的文件都是可执行的、普通用户都能使用的命令。作为基础系统所需要的最基础的命令就是放在这里。</td>
</tr>
<tr>
<td style="text-align:right">/boot</td>
<td>Linux的内核及引导系统程式所需要的文件目录，比如 vmlinuz initrd.img 文件都位于这个目录中。在一般情况下，GRUB或LILO系统引导管理器也位于这个目录；</td>
</tr>
<tr>
<td style="text-align:right">/dev</td>
<td>设备文件存储目录，比如声卡、磁盘… …</td>
</tr>
<tr>
<td style="text-align:right">/etc</td>
<td>系统设置文件的所在地，一些服务器的设置文件也在这里；比如用户帐号及密码设置文件；</td>
</tr>
<tr>
<td style="text-align:right">/home</td>
<td>普通用户家目录默认存放目录；</td>
</tr>
<tr>
<td style="text-align:right">/lib</td>
<td>库文件存放目录</td>
</tr>
<tr>
<td style="text-align:right">/lost+found</td>
<td>在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已损坏的文件系统。 有时系统发生问题，有非常多的文件被移到这个目录中，可能会用手工的方式来修复，或移到文件到原来的位置上。</td>
</tr>
<tr>
<td style="text-align:right">/mnt</td>
<td>这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom 等目录。能参看/etc/fstab的定义。有时我们能把让系统开机自动挂载文件系统，把挂载点放在这里也是能的。主要看/etc/fstab中怎么定义了；比如光驱能挂载到/mnt/cdrom 。</td>
</tr>
<tr>
<td style="text-align:right">/opt</td>
<td>表示的是可选择的意思，有些软件包也会被安装在这里，也就是自定义软件包，比如在Fedora Core 5.0中，OpenOffice就是安装在这里。有些我们自己编译的软件包，就能安装在这个目录中；通过源码包安装的软件，能通过 ./configure —prefix=/opt/目录 。</td>
</tr>
<tr>
<td style="text-align:right">/proc</td>
<td>操作系统运行时，进程信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录伪装的文件系统proc的挂载目录，proc并不是真正的文件系统，他的定义能参见 /etc/fstab 。</td>
</tr>
<tr>
<td style="text-align:right">/root</td>
<td>Linux终极权限用户root的家目录；</td>
</tr>
<tr>
<td style="text-align:right">/sbin</td>
<td>大多是涉及系统管理的命令的存放，是终极权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令，这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin目录是相似的；我们记住就行了，凡是目录sbin中包含的都是root权限才能执行的。</td>
</tr>
<tr>
<td style="text-align:right">/tmp</td>
<td>临时文件目录，有时用户运行程式的时候，会产生临时文件。/tmp就用来存放临时文件的。/var/tmp目录和这个目录相似。</td>
</tr>
<tr>
<td style="text-align:right">/usr</td>
<td>这个是系统存放程式的目录，比如命令、帮助文件等。这个目录下有非常多的文件和目录。当我们安装一个Linux发行版官方提供的软件包时，大多安装在这里。 如果有涉及服务器设置文件的，会把设置文件安装在/etc目录中。/usr目录下包括涉及字体目录/usr/share/fonts ，帮助目录 /usr/share/man或/usr/share/doc，普通用户可执行文件目录/usr/bin 或/usr/local/bin 或/usr/X11R6/bin ，终极权限用户root的可执行命令存放目录，比如 /usr/sbin 或/usr/X11R6/sbin 或/usr/local/sbin 等；更有程式的头文件存放目录/usr/include。</td>
</tr>
<tr>
<td style="text-align:right">/var</td>
<td>这个目录的内容是经常变动的，看名字就知道，我们能理解为vary的缩写，/var下有/var/log 这是用来存放系统日志的目录。/var/www目录是定义Apache服务器站点存放目录；/var/lib 用来存放一些库文件，比如MySQL的，及MySQL数据库的的存放地；</td>
</tr>
</tbody>
</table>
<h2 id="/dev目录">/dev目录</h2>
<p>dev是设备(device)的英文缩写。/dev这个目录对所有的用户都十分重要。因为在这个目录中包含了所有Linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序，这一点和windows,dos操作系统不一样。它实际上是一个访问这些外部设备的端口。我们可以非常方便地去访问这些外部设备，和访问一个文件，一个目录没有任何区别。</p>
<pre><code>Linux沿袭Unix的风格，将所有设备认成是一个文件。
</code></pre><p>设备文件分为两种：块设备文件(b)和字符设备文件(c)，<code>设备文件一般存放在/dev目录下</code>，对常见设备文件作如下说明：</p>
<table>
<thead>
<tr>
<th style="text-align:right">目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">/dev/hd[a-t]：</td>
<td>IDE设备</td>
</tr>
<tr>
<td style="text-align:right">/dev/sd[a-z]：</td>
<td>SCSI设备</td>
</tr>
<tr>
<td style="text-align:right">/dev/fd[0-7]：</td>
<td>标准软驱</td>
</tr>
<tr>
<td style="text-align:right">/dev/md[0-31]：</td>
<td>软raid设备</td>
</tr>
<tr>
<td style="text-align:right">/dev/loop[0-7]：</td>
<td>本地回环设备</td>
</tr>
<tr>
<td style="text-align:right">/dev/ram[0-15]：</td>
<td>内存</td>
</tr>
<tr>
<td style="text-align:right">/dev/null：</td>
<td>无限数据接收设备,相当于黑洞</td>
</tr>
<tr>
<td style="text-align:right">/dev/zero：</td>
<td>无限零资源</td>
</tr>
<tr>
<td style="text-align:right">/dev/tty[0-63]：</td>
<td>虚拟终端</td>
</tr>
<tr>
<td style="text-align:right">/dev/ttyS[0-3]：</td>
<td>串口</td>
</tr>
<tr>
<td style="text-align:right">/dev/lp[0-3]：</td>
<td>并口</td>
</tr>
<tr>
<td style="text-align:right">/dev/console：</td>
<td>控制台</td>
</tr>
<tr>
<td style="text-align:right">/dev/fb[0-31]：</td>
<td>framebuffer</td>
</tr>
<tr>
<td style="text-align:right">/dev/cdrom =&gt;</td>
<td>/dev/hdc</td>
</tr>
<tr>
<td style="text-align:right">/dev/modem =&gt;</td>
<td>/dev/ttyS[0-9]</td>
</tr>
<tr>
<td style="text-align:right">/dev/pilot =&gt;</td>
<td>/dev/ttyS[0-9]</td>
</tr>
<tr>
<td style="text-align:right">/dev/random：</td>
<td>随机数设备</td>
</tr>
<tr>
<td style="text-align:right">/dev/urandom：</td>
<td>随机数设备</td>
</tr>
</tbody>
</table>
<h2 id="/etc目录">/etc目录</h2>
<table>
<thead>
<tr>
<th style="text-align:right">目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">/etc/rc，/etc/rc.d，/etc/rc*.d</td>
<td><code>启动、或改变运行级时运行的scripts或scripts的目录。</code></td>
</tr>
<tr>
<td style="text-align:right">/etc/passwd</td>
<td><code>用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息</code>。</td>
</tr>
<tr>
<td style="text-align:right">/etc/fstab</td>
<td>启动时mount -a命令(在/etc/rc 或等效的启动文件中)自动mount的文件系统列表。Linux下，也包括用swapon -a启用的swap区的信息。</td>
</tr>
<tr>
<td style="text-align:right">/etc/group</td>
<td>类似/etc/passwd ，但说明的不是用户而是<code>用户组</code>。</td>
</tr>
<tr>
<td style="text-align:right">/etc/inittab</td>
<td>init 的配置文件，设定系统启动时init进程将把系统设置成什么样的runlevel 。</td>
</tr>
<tr>
<td style="text-align:right">/etc/issue</td>
<td>getty 在登录提示符前的输出信息.通常包括系统的一段短说明或欢迎信息内容由系统管理员确定。</td>
</tr>
<tr>
<td style="text-align:right">/etc/motd</td>
<td>Message Of The Day 成功登录后自动输出内容由系统管理员确定，经常用于通告信息，如计划关机时间的警告。</td>
</tr>
<tr>
<td style="text-align:right">/etc/mtab</td>
<td>当前安装的文件系统列表.由scripts初始化，并由mount 命令自动更新，需要一个当前安装的文件系统的列表时使用，例如df 命令。</td>
</tr>
<tr>
<td style="text-align:right">/etc/shadow</td>
<td>在安装了影子口令软件的系统上的影子口令文件.影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow 中，而后者只对root可读这使破译口令更困难.</td>
</tr>
<tr>
<td style="text-align:right">/etc/login.defs login</td>
<td>命令的配置文件。</td>
</tr>
<tr>
<td style="text-align:right">/etc/printcap 类似/etc/termcap</td>
<td>但针对打印机语法不同。</td>
</tr>
<tr>
<td style="text-align:right">/etc/profile , /etc/csh.login , /etc/csh.cshrc</td>
<td>登录或启动时Bourne或C shells执行的文件，这允许系统管理员为所有用户建立全局缺省环境。</td>
</tr>
<tr>
<td style="text-align:right">/etc/securetty</td>
<td>确认安全终端，即哪个终端允许root登录.一般只列出虚拟控制台，这样就不可能(至少很困难)通过modem或网络闯入系统并得到超级用户特权。</td>
</tr>
<tr>
<td style="text-align:right">/etc/shells</td>
<td>列出可信任的shell.chsh 命令允许用户在本文件指定范围内改变登录shell.提供一台机器FTP服务的服务进程ftpd 检查用户shell是否列在 /etc/shells 文件中，如果不是将不允许该用户登录.</td>
</tr>
<tr>
<td style="text-align:right">/etc/sysconfig</td>
<td>网络配置相关目录</td>
</tr>
<tr>
<td style="text-align:right">/etc/DIR_COLORS</td>
<td><code>设定颜色</code></td>
</tr>
<tr>
<td style="text-align:right">/etc/HOSTNAME</td>
<td>设定用户的节点名</td>
</tr>
<tr>
<td style="text-align:right">/etc/NETWORKING</td>
<td>只有YES标明网络存在</td>
</tr>
<tr>
<td style="text-align:right">/etc/host.conf</td>
<td>文件说明用户的系统如何查询节点名</td>
</tr>
<tr>
<td style="text-align:right">/etc/hosts</td>
<td>设定用户自已的IP与名字的对应表</td>
</tr>
<tr>
<td style="text-align:right">/etc/hosts.allow</td>
<td>设置允许使用inetd的机器使用</td>
</tr>
<tr>
<td style="text-align:right">/etc/hosts.deny</td>
<td>设置不允许使用inetd的机器使用</td>
</tr>
<tr>
<td style="text-align:right">/etc/hosts.equiv</td>
<td>设置远端机不用密码</td>
</tr>
<tr>
<td style="text-align:right">/etc/inetd.conf</td>
<td>设定系统网络守护进程inetd的配置</td>
</tr>
<tr>
<td style="text-align:right">/etc/inetd.pid</td>
<td>inetd这个进程的进程id</td>
</tr>
<tr>
<td style="text-align:right">/etc/hosts.lpd</td>
<td>设定远端有哪些节点可以使用本机的打印机</td>
</tr>
<tr>
<td style="text-align:right">/etc/gateways</td>
<td>设定路由器</td>
</tr>
<tr>
<td style="text-align:right">/etc/protocols</td>
<td>设定系统支持的协议</td>
</tr>
<tr>
<td style="text-align:right">/etc/named.boot</td>
<td>设定本机为名字服务器的配置文件</td>
</tr>
<tr>
<td style="text-align:right">/etc/named.pid</td>
<td><code>本机上运行的名字服务器的进程id</code></td>
</tr>
<tr>
<td style="text-align:right">/etc/networks</td>
<td>设定网络的配置文件</td>
</tr>
<tr>
<td style="text-align:right">/etc/resolv.conf</td>
<td><code>设定系统的名字服务器</code></td>
</tr>
<tr>
<td style="text-align:right">/etc/services</td>
<td>设定系统的端品与协议类型和提供的服务</td>
</tr>
<tr>
<td style="text-align:right">/etc/exports</td>
<td><code>设定NFS系统用的</code></td>
</tr>
<tr>
<td style="text-align:right">/etc/NNTP_INEWS_DOMAIN</td>
<td>设置新闻服务器的配置文件</td>
</tr>
<tr>
<td style="text-align:right">/etc/nntpserver</td>
<td>设置用户使用的新闻服务器的地址</td>
</tr>
<tr>
<td style="text-align:right">/etc/XF86Config</td>
<td>X Window的配置文件</td>
</tr>
<tr>
<td style="text-align:right">/etc/hostid</td>
<td>系统独有的一个硬件id</td>
</tr>
<tr>
<td style="text-align:right">/etc/at.deny</td>
<td>设置哪些用户不能使用at命令</td>
</tr>
<tr>
<td style="text-align:right">/etc/bootptab</td>
<td>给MAKEDEV程序设定各种不同的设备驱动文件的格式</td>
</tr>
<tr>
<td style="text-align:right">/etc/makedev.cfg</td>
<td>同DEVINFO一样给MAKEDEV使用的设置文件</td>
</tr>
<tr>
<td style="text-align:right">/etc/diphosts</td>
<td>设置拔号服务器的用户名和口令</td>
</tr>
<tr>
<td style="text-align:right">/etc/slip.hosts,/etc/slip.login</td>
<td>设定SLIP的配置文件</td>
</tr>
<tr>
<td style="text-align:right">/etc/fastboot</td>
<td>使用shutdown -f产生的，重启系统要查这个文件</td>
</tr>
<tr>
<td style="text-align:right">/etc/fstab</td>
<td><code>记录开机要mount的文件系统</code></td>
</tr>
<tr>
<td style="text-align:right">/etc/ftpaccess</td>
<td><code>FTP服务器的一些配置</code></td>
</tr>
<tr>
<td style="text-align:right">/etc/ftpconversions</td>
<td>设定在FTP时使用的过滤器的位置</td>
</tr>
<tr>
<td style="text-align:right">/etc/ftpusers</td>
<td><code>设定不能使用FTP服务的用户</code></td>
</tr>
<tr>
<td style="text-align:right">/etc/ld.so.cache</td>
<td>查找系统动态链接库的缓存</td>
</tr>
<tr>
<td style="text-align:right">/etc/ld.so.conf</td>
<td>系统动态链接库的路径</td>
</tr>
<tr>
<td style="text-align:right">/etc/lilo.conf</td>
<td>lilo的配置文件</td>
</tr>
<tr>
<td style="text-align:right">/etc/magic</td>
<td>给file命令使用的</td>
</tr>
<tr>
<td style="text-align:right">/etc/aliases</td>
<td>给sendmail使用的设置别名的文件</td>
</tr>
<tr>
<td style="text-align:right">/etc/mail.rc, /etc/mailcap, /etc/sendmail.cf, /etc/sendmail.st</td>
<td>设置sendmail的</td>
</tr>
<tr>
<td style="text-align:right">/etc/motd</td>
<td>超级用户发布通知的地方</td>
</tr>
<tr>
<td style="text-align:right">/etc/organization</td>
<td>存放用户的名字和组织</td>
</tr>
<tr>
<td style="text-align:right">/etc/pnpdevices</td>
<td>列出支持的Plug&amp;Play设备</td>
</tr>
<tr>
<td style="text-align:right">/etc/snooptad</td>
<td>监控用户的屏幕，监听的终端列表</td>
</tr>
<tr>
<td style="text-align:right">/etc/sudoers</td>
<td><code>可以sudo命令的配置文件</code></td>
</tr>
<tr>
<td style="text-align:right">/etc/syslog.conf</td>
<td>系统记录程序syslogd的配置文件</td>
</tr>
<tr>
<td style="text-align:right">/etc/utmp</td>
<td>目前在用系统的用户信息</td>
</tr>
<tr>
<td style="text-align:right">/etc/wtmp</td>
<td>同utmp差不多，只是它累加</td>
</tr>
<tr>
<td style="text-align:right">/etc/nologin</td>
<td>系统在shutdown时不希望用户登录就产生这个文件</td>
</tr>
<tr>
<td style="text-align:right">/etc/termcap</td>
<td>设置系统终端信息的</td>
</tr>
<tr>
<td style="text-align:right">/etc/ttys</td>
<td>设定系统的终端类型</td>
</tr>
<tr>
<td style="text-align:right">/etc/gettydefs</td>
<td>getty_ps的定义文件</td>
</tr>
<tr>
<td style="text-align:right">/etc/yp.conf</td>
<td>NIS的配置文件</td>
</tr>
<tr>
<td style="text-align:right">/etc/mtools.conf</td>
<td>设定mtools程序的参数</td>
</tr>
<tr>
<td style="text-align:right">/etc/fdprm</td>
<td>设定格式化软盘的参数</td>
</tr>
<tr>
<td style="text-align:right">/etc/login.access</td>
<td>控制用户登录权限的文件</td>
</tr>
</tbody>
</table>
<h2 id="/proc目录">/proc目录</h2>
<table>
<thead>
<tr>
<th style="text-align:right">目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">/proc/cmdline</td>
<td>加载 kernel 时所下达的相关参数，查阅此文件，可了解系统是如何启动。</td>
</tr>
<tr>
<td style="text-align:right">/proc/cpuinfo</td>
<td>本机的 <code>CPU 的相关资讯，包含时脉、类型与运算功能等</code></td>
</tr>
<tr>
<td style="text-align:right">/proc/devices</td>
<td>这个文件记录了系统各个主要装置的主要装置代号，与 mknod 有关。</td>
</tr>
<tr>
<td style="text-align:right">/proc/filesystems</td>
<td>目前系统已经加载的文件系统。</td>
</tr>
<tr>
<td style="text-align:right">/proc/interrupts</td>
<td>目前系统上面的 <code>IRQ 分配状态</code></td>
</tr>
<tr>
<td style="text-align:right">/proc/ioports</td>
<td>目前系统上面各个装置所配置的 <code>I/O 位址</code>。</td>
</tr>
<tr>
<td style="text-align:right">/proc/kcore</td>
<td>这个就是内存的大小，但是不要读他。</td>
</tr>
<tr>
<td style="text-align:right">/proc/loadavg</td>
<td>还记得 top 以及 uptime 吧？没错，上头的三个平均数值就是记录在此。</td>
</tr>
<tr>
<td style="text-align:right">/proc/meminfo</td>
<td>使用 free 列出的内存资讯，在这里也能够查阅到。</td>
</tr>
<tr>
<td style="text-align:right">/proc/modules</td>
<td>目前我们的 Linux 已经加载的模块列表，也可以想成是驱动程序。</td>
</tr>
<tr>
<td style="text-align:right">/proc/mounts</td>
<td>系统已经挂载的数据，就是用 <code>mount</code> 这个命令呼叫出来的数据。</td>
</tr>
<tr>
<td style="text-align:right">/proc/swaps</td>
<td>到底系统挂加载的内存在哪里？使用掉的 partition 就记录在此啦。</td>
</tr>
<tr>
<td style="text-align:right">/proc/partitions</td>
<td>使用 <code>fdisk -l</code> 会出现目前所有的 partition 吧？在这个文件当中也有</td>
</tr>
<tr>
<td style="text-align:right">/proc/pci</td>
<td>在 PCI 汇流排上面，每个装置的详细情况，可用 <code>lspci</code> 来查阅。</td>
</tr>
<tr>
<td style="text-align:right">/proc/uptime</td>
<td>就是用 uptime 的时候，会出现的资讯。</td>
</tr>
<tr>
<td style="text-align:right">/proc/version</td>
<td>核心的版本，就是用 <code>uname -a</code>显示的内容。</td>
</tr>
<tr>
<td style="text-align:right">/proc/bus/*</td>
<td>一些汇流排的装置，还有 U盘 的装置也记录在此。</td>
</tr>
</tbody>
</table>
<h2 id="/usr目录">/usr目录</h2>
<table>
<thead>
<tr>
<th style="text-align:right">目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">/usr</td>
<td>最庞大的目录，因为<code>所有应用程序几乎都安装在这里</code>， <code>本地安装的程序和其他东西在/usr/local 下</code>。</td>
</tr>
<tr>
<td style="text-align:right">/usr/etc</td>
<td>存放<code>配置文件</code>。</td>
</tr>
<tr>
<td style="text-align:right">/usr/games</td>
<td>存放<code>游戏和教学</code>文件。</td>
</tr>
<tr>
<td style="text-align:right">/usr/include</td>
<td>开发和编译应用程序所需要的<code>头文件</code>。</td>
</tr>
<tr>
<td style="text-align:right">/usr/share</td>
<td>存放结构独立的数据。</td>
</tr>
<tr>
<td style="text-align:right">/usr/bin</td>
<td>几乎所有<code>用户命令</code>.有些命令在/bin 或/usr/local/bin 中。</td>
</tr>
<tr>
<td style="text-align:right">/usr/sbin</td>
<td>根文件系统不必要的<code>系统管理命令</code>，例如多数服务程序。</td>
</tr>
<tr>
<td style="text-align:right">/usr/share/man , /usr/share/info , /usr/share/doc</td>
<td><code>手册页、GNU信息</code>文档和各种其他文档文件。</td>
</tr>
<tr>
<td style="text-align:right">/usr/lib</td>
<td>程序或子系统的不变的数据文件，包括一些<code>site-wide配置文件</code>，名字lib来源于库(library)， 编程的原始库存在/usr/lib 里。</td>
</tr>
<tr>
<td style="text-align:right">/usr/local</td>
<td><code>本地安装的软件</code>和<code>其他文件放在这里</code>，<code>/usr/local/bin</code>存放本地增加的命令，<code>/usr/local/include</code>存放本地增加的库文件。</td>
</tr>
<tr>
<td style="text-align:right">/usr/src</td>
<td>存放程序的源代码，<code>linux内核的源代码存放在/usr/src/kernels</code>。</td>
</tr>
</tbody>
</table>
<h2 id="/var目录">/var目录</h2>
<table>
<thead>
<tr>
<th style="text-align:right">目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">/var</td>
<td>包括系统一般运行时要改变的数据.每个系统是特定的，即不通过网络与其他计算机共享。</td>
</tr>
<tr>
<td style="text-align:right">/var/catman</td>
<td>当要求格式化时的man页的cache.man页的源文件一般存在/usr/man/man<em> 中；有些man页可能有预格式化的版本，存在/usr/man/cat</em> 中.而其他的man页在第一次看时需要格式化，格式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了. (/var/catman 经常被清除，就象清除临时目录一样.)</td>
</tr>
<tr>
<td style="text-align:right">/var/lib</td>
<td><code>系统正常运行时要改变的文件</code>。</td>
</tr>
<tr>
<td style="text-align:right">/var/local，/usr/local</td>
<td>中安装的程序的可变数据(即系统管理员安装的程序).注意，如果必要，即使本地安装的程序也会使用其他/var 目录，例如/var/lock 。</td>
</tr>
<tr>
<td style="text-align:right">/var/lock</td>
<td>锁定文件.许多程序遵循在/var/lock 中产生一个锁定文件的约定，以支持他们正在使用某个特定的设备或文件.其他程序注意到这个锁定文件，将不试图使用这个设备或文件。</td>
</tr>
<tr>
<td style="text-align:right">/var/log</td>
<td>各种<code>程序的Log文件</code>，特别是login (/var/log/wtmp log所有到系统的登录和注销) 和syslog (/var/log/messages 里存储所有核心和系统程序信息. /var/log 里的文件经常不确定地增长，应该定期清除。</td>
</tr>
<tr>
<td style="text-align:right">/var/run</td>
<td>保存到下次引导前有效的关于系统的信息文件.例如， <code>/var/run/utmp 包含当前登录的用户的信息</code>。</td>
</tr>
<tr>
<td style="text-align:right">/var/spool，/var/mail, /var/news</td>
<td><code>打印队列和其他队列工作的目录</code>.每个不同的spool在/var/spool 下有自己的子目录，例如，用户的邮箱在/var/spool/mail 中。</td>
</tr>
<tr>
<td style="text-align:right">/var/tmp</td>
<td>比/tmp <code>允许的大或需要存在较长时间的临时文件</code>。 (虽然系统管理员可能不允许/var/tmp 有很旧的文件.)</td>
</tr>
</tbody>
</table>
<h2 id="比较重要的目录">比较重要的目录</h2>
<p>在 Linux 系统中，有几个目录是特别需要注意的，以下提供几个需要注意的目录，以及预设相关的用途：　</p>
<table>
<thead>
<tr>
<th style="text-align:right">目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">/etc：</td>
<td>这个目录相当重要，如前所述，你的开机与系统数据文件均在这个目录之下，因此当这个目录被破坏，那你的系统大概也就差不多该死掉了！而在往后的文件中，你会发现我们常常使用这个目录下的 /etc/rc.d/init.d 这个子目录，因为这个 init.d 子目录是开启一些 Linux 系统服务的 scripts （可以想成是批次檔 ）的地方。而在 /etc/rc.d/rc.local 这个文件是开机的执行档。　</td>
</tr>
<tr>
<td style="text-align:right">/bin, /sbin, /usr/bin, /usr/sbin：</td>
<td>这是系统预设的执行文件的放置目录，例如 root 常常使用的 userconf, netconf, perl, gcc, c++ 等等的数据都放在这几个目录中，所以如果你在提示字符下找不到某个执行档时，可以在这四个目录中查一查！其中， /bin, /usr/bin 是给系统使用者使用的指令，而 /sbin, /usr/sbin 则是给系统管理员使用的指令！  　</td>
</tr>
<tr>
<td style="text-align:right">/usr/local：</td>
<td>这是系统预设的让你安装你后来升级的套件的目录。例如，当你发现有更新的 Web 套件（如 Apache ）可以安装，而你又不想以 rpm 的方式升级你的套件，则你可以将 apache 这个套件安装在 /usr/local 底下。安装在这里有个好处，因为目前大家的系统都是差不多的，所以如果你的系统要让别人接管的话，也比较容易上手呀！也比较容易找的到数据喔！因此，如果你有需要的话，通常我都会将 /usr/local/bin 这个路径加到我的 path 中。　</td>
</tr>
<tr>
<td style="text-align:right">/home：</td>
<td>这个是系统将有账号的人口的家目录设置的地方。    　</td>
</tr>
<tr>
<td style="text-align:right">/var：</td>
<td>这个路径就重要了！不论是登入、各类服务的问题发生时的记录、以及常态性的服务记录等等的记录目录，所以当你的系统有问题时，就需要来这个目录记录的文件数据中察看问题的所在啰！而 mail 的预设放置也是在这里，所以他是很重要的    　</td>
</tr>
<tr>
<td style="text-align:right">/usr/share/man, /usr/local/man：</td>
<td>这两个目录为放置各类套件说明档的地方，例如你如果执行 man man，则系统会自动去找这两个目录下的所有说明文件</td>
</tr>
</tbody>
</table>
<h2 id="一些重要子目录的解说">一些重要子目录的解说</h2>
<p>下面飘扬再补充几个比较常见且非常重要的目录。</p>
<table>
<thead>
<tr>
<th style="text-align:right">目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">etc/init.d</td>
<td>这个目录是用来存放系统或服务器以System V模式启动的脚本，这在以System V模式启动或初始化的系统中常见。比如Fedora/RedHat；</td>
</tr>
<tr>
<td style="text-align:right">/etc/xinit.d</td>
<td>如果服务器是通过xinetd模式运行的，他的脚本要放在这个目录下。有些系统没有这个目录， 比如Slackware，有些老的版本也没有。在Rehat/Fedora中比较新的版本中存在。</td>
</tr>
<tr>
<td style="text-align:right">/etc/rc.d</td>
<td>这是Slackware发行版有的一个目录，是BSD方式启动脚本的存放地；比如定义网卡，服务器开启脚本等。</td>
</tr>
<tr>
<td style="text-align:right">/etc/X11</td>
<td>这是X-视窗系统相关的设置文件存放地。</td>
</tr>
<tr>
<td style="text-align:right">/usr/bin</td>
<td>这个目录是可执行程式的目录，普通用户就有权限执行；当我们从系统自带的软件包安装一个程式时，他的可执行文件大多会放在这个目录。比如安装gaim软件包时。相似的目录是/usr/local/bin；有时/usr/bin中的文件是/usr/local/bin的链接文件；</td>
</tr>
<tr>
<td style="text-align:right">/usr/sbin</td>
<td>这个目录也是可执行程式的目录，但大多存放涉及系统管理的命令。只有root权限才能执行；相似目录是/sbin 或/usr/local/sbin或/usr/X11R6/sbin等；</td>
</tr>
<tr>
<td style="text-align:right">/usr/local</td>
<td>这个目录一般是用来存放用户自编译安装软件的存放目录；一般是通过源码包安装的软件，如果没有特别指定安装目录的话，一般是安装在这个目录中。这个目录下面有子目录。自己看看吧。</td>
</tr>
<tr>
<td style="text-align:right">/usr/share</td>
<td>系统共用的东西存放地，比如 /usr/share/fonts 是字体目录，/usr/share/doc和/usr/share/man帮助文件。</td>
</tr>
<tr>
<td style="text-align:right">/usr/src</td>
<td>是内核源码存放的目录，比如下面有内核源码目录，比如linux 、linux-2.xxx.xx目录等。有的系统也会把源码软件包安装在这里。比如Fedora/Redhat，当我们安装file.src.rpm的时候，这些软件包会安装在/usr/src/redhat相应的目录中。</td>
</tr>
<tr>
<td style="text-align:right">/var/adm</td>
<td>比如软件包安装信息、日志、管理信息等，在Slackware操作系统中是有这个目录的。在Fedora中好象没有；自己看看吧。</td>
</tr>
<tr>
<td style="text-align:right">/var/log</td>
<td>系统日志存放，分析日志要看这个目录的东西；</td>
</tr>
<tr>
<td style="text-align:right">/var/spool</td>
<td>打印机、邮件、代理服务器等假脱机目录；</td>
</tr>
</tbody>
</table>
<h2 id="目录结构的简明查阅手册">目录结构的简明查阅手册</h2>
<h3 id="“/”根目录部分有以下子目录：">“/”根目录部分有以下子目录：</h3>
<table>
<thead>
<tr>
<th style="text-align:right">目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">/usr</td>
<td>目录包含所有的命令、程式库、文件和其他文件。这些文件在正常操作中不会被改动的。这个目录也包含你的Linux发行版本的主要的应用程式，譬如，Netscape。</td>
</tr>
<tr>
<td style="text-align:right">/var</td>
<td>目录包含在正常操作中被改动的文件：假脱机文件、记录文件、加锁文件、临时文件和页格式化文件等</td>
</tr>
<tr>
<td style="text-align:right">/home</td>
<td>目录包含用户的文件：参数设置文件、个性化文件、文件、数据、EMAIL、缓存数据等。这个目录在系统省级时应该保留。</td>
</tr>
<tr>
<td style="text-align:right">/proc</td>
<td>目录整个包含虚幻的文件。他们实际上并不存在磁盘上，也不占用所有空间。（用ls ?l 能显示他们的大小）当查看这些文件时，实际上是在访问存在内存中的信息，这些信息用于访问系统</td>
</tr>
<tr>
<td style="text-align:right">/bin</td>
<td>系统启动时需要的执行文件（二进制），这些文件能被普通用户使用。</td>
</tr>
<tr>
<td style="text-align:right">/sbin</td>
<td>系统执行文件（二进制），这些文件不打算被普通用户使用。（普通用户仍然能使用他们，但要指定目录。）</td>
</tr>
<tr>
<td style="text-align:right">/etc</td>
<td>操作系统的设置文件目录。</td>
</tr>
<tr>
<td style="text-align:right">/root</td>
<td>系统管理员（也叫终极用户或根用户）的Home目录。</td>
</tr>
<tr>
<td style="text-align:right">/dev</td>
<td>设备文件目录。LINUX下设备被当成文件，这样一来硬件被抽象化，便于读写、网络共享及需要临时装载到文件系统中。正常情况下，设备会有一个独立的子目录。这些设备的内容会出目前独立的子目录下。LINUX没有所谓的驱动符。</td>
</tr>
<tr>
<td style="text-align:right">/lib</td>
<td>根文件系统目录下程式和核心模块的共享库。</td>
</tr>
<tr>
<td style="text-align:right">/boot</td>
<td>用于自举加载程式（LILO或GRUB）的文件。当计算机启动时（如果有多个操作系统，有可能允许你选择启动哪一个操作系统），这些文件首先被装载。这个目录也会包含LINUX核（压缩文件vmlinuz），但LINUX核也能存在别处，只要设置LILO并且LILO知道LINUX核在哪儿。</td>
</tr>
<tr>
<td style="text-align:right">/opt</td>
<td>可选的应用程式，譬如，REDHAT 5.2下的KDE（REDHAT 6.0下，KDE放在其他的XWINDOWS应用程式中，主执行程式在/usr/bin目录下）</td>
</tr>
<tr>
<td style="text-align:right">/tmp</td>
<td>临时文件。该目录会被自动清理干净。</td>
</tr>
<tr>
<td style="text-align:right">/lost+found</td>
<td>在文件系统修复时恢复的文件</td>
</tr>
</tbody>
</table>
<h3 id="“/usr”目录下比较重要的部分有：">“/usr”目录下比较重要的部分有：</h3>
<table>
<thead>
<tr>
<th style="text-align:right">目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">/usr/X11R6</td>
<td>X-WINDOWS系统（version 11, release 6)</td>
</tr>
<tr>
<td style="text-align:right">/usr/X11</td>
<td>同/usr/X11R6 （/usr/X11R6的符号连接）</td>
</tr>
<tr>
<td style="text-align:right">/usr/X11R6/bin</td>
<td>大量的小X-WINDOWS应用程式（也可能是一些在其他子目录下大执行文件的符号连接）。</td>
</tr>
<tr>
<td style="text-align:right">/usr/doc</td>
<td>LINUX的文件资料（在更新的系统中，这个目录移到/usr/share/doc）。</td>
</tr>
<tr>
<td style="text-align:right">/usr/share</td>
<td>独立和你计算机结构的数据，譬如，字典中的词。</td>
</tr>
<tr>
<td style="text-align:right">/usr/bin和/usr/sbin</td>
<td>类似和“/”根目录下对应的目录（/bin和/sbin），但不用于基本的启动（譬如，在紧急维护中）。大多数命令在这个目录下。</td>
</tr>
<tr>
<td style="text-align:right">/usr/local</td>
<td>本地管理员安装的应用程式（也可能每个应用程式有独立的子目录）。在“main”安装后，这个目录可能是空的。这个目录下的内容在重安装或升级操作系统后应该存在。</td>
</tr>
<tr>
<td style="text-align:right">/usr/local/bin</td>
<td>可能是用户安装的小的应用程式，和一些在/usr/local目录下大应用程式的符号连接。</td>
</tr>
</tbody>
</table>
<h3 id="“/proc”目录的内容：">“/proc”目录的内容：</h3>
<table>
<thead>
<tr>
<th style="text-align:right">目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">/proc/cpuinfo</td>
<td>关于处理器的信息，如类型、厂家、型号和性能等。</td>
</tr>
<tr>
<td style="text-align:right">/proc/devices</td>
<td>当前运行内核所设置的所有设备清单。</td>
</tr>
<tr>
<td style="text-align:right">/proc/dma</td>
<td>当前正在使用的DMA通道。/proc/filesystems 当前运行内核所设置的文件系统。</td>
</tr>
<tr>
<td style="text-align:right">/proc/interrupts</td>
<td>正在使用的中断，和原来有多少个中断。</td>
</tr>
<tr>
<td style="text-align:right">/proc/ioports</td>
<td>当前正在使用的I/O端口。</td>
</tr>
</tbody>
</table>
<h2 id="linux与windows的文件目录对比">linux与windows的文件目录对比</h2>
<p>linux与windows的文件夹没有可对比之处，也没有对应的<br>不过非要说的话，按照软件安装时的行为，也可以有对应的</p>
<p>比如说，linux安装软件时一般会默认安装到<code>/usr/local</code>下，而windows下默认安装到<code>c:\program files</code>下，所以从这里看，它们两者对应</p>
<p>类似的，<code>/bin</code>  <code>/sbin</code>  <code>/usr/bin</code>  <code>/usr/sbin</code>  <code>/usr/local/xxx/bin</code>  和  <code>/usr/local/xxx/sbin</code> 这几个文件夹都相当于<code>c:\windows</code>,因为PATH变量会优先搜寻这几个目录，而windows的PATH一般会优先搜寻c:\windows</p>
<p>/etc  /usr/local/etc /usr/local/xxx/etc 这几个没有可对应的</p>
<p><code>/（根目录）</code>，也没有可对应的,若非要说有，<code>c:\</code>免强说得过去</p>
<p><code>~root/ 或~用户名/</code> , 就相当于<code>C:\Users\用户名(windows也可以用环境变量 %userprofile% 表示)</code> 表示)，<code>root对应于administrator</code></p>
<p>/dev 没有可对应的</p>
<p>/usr/src 也没有可对应的（windows可不提供给你源码!)</p>
<p><code>/home</code> 对应于<code>C:\Users</code></p>
<p><code>/tmp</code> 对应于 <code>%temp% 或 %tmp% (环境变量表示的路径)</code></p>
<p>不错的网站（备用）：<a href="http://vbird.dic.ksu.edu.tw/linux_basic/linux_basic.php" target="_blank" rel="external">鸟哥的私房菜</a></p>
]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[app.md]]></title>
    <link href="http://pleasureswx123.github.io/2014/09/12/appmd/"/>
    <id>http://pleasureswx123.github.io/2014/09/12/appmd/</id>
    <published>2014-09-12T06:25:57.000Z</published>
    <updated>2014-09-12T06:32:35.000Z</updated>
    <content type="html"><![CDATA[<h1 id="制作APP过程">制作APP过程</h1>
<h2 id="在node上安装cordova">在node上安装cordova</h2>
<pre><code><span class="number">1</span> C:\&gt;npm install -g cordova<span class="comment"> //安装</span>
<span class="number">2</span> $ cordova <span class="built_in">create</span> hello com.example.hello HelloWorld<span class="comment"> //创建一个helloworld的APP</span>
<span class="number">3</span> $ cd hello<span class="comment"> //进入APP</span>
<span class="number">4</span> $ cordova <span class="built_in">platform</span> <span class="built_in">add</span> android <span class="comment"> //添加android平台</span>
</code></pre><p>就OK了,它自动生成的有很多文件,主要改底下有一个www目录下的文件，在前端的任何编辑下打开编辑就行了。</p>
<p>做好后，打包的话，先运行</p>
<pre><code><span class="variable">$ </span>cordova build
</code></pre><p>这个命令行，是把你刚刚编辑的前端代码，自动编译成android语言，会自动替换到android目录，</p>
<p>再用usb把手机连接到电脑上，最后再运行</p>
<pre><code><span class="variable">$ </span>cordova run android
</code></pre><p>然后手机上就会自动把这个应用安装到手机上了</p>
]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[Yeoman安装.md]]></title>
    <link href="http://pleasureswx123.github.io/2014/09/11/Yeoman%E5%AE%89%E8%A3%85md/"/>
    <id>http://pleasureswx123.github.io/2014/09/11/Yeoman安装md/</id>
    <published>2014-09-11T11:51:59.000Z</published>
    <updated>2014-10-27T05:46:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在_Windows_上安装_Yeoman">在 Windows 上安装 Yeoman</h1>
<pre><code>条件：注意先能够翻墙，因为下面要下载很多东西，如果是墙外的，可能会不成功。
</code></pre><h2 id="什么场景下使用yeoman？">什么场景下使用yeoman？</h2>
<p>假设，接到一个项目：火车票订票系统，代码层面，前几天思考的问题如下：</p>
<pre><code><span class="number">1</span>.项目目录该如何规划？
<span class="number">2</span>.使用什么类库来支撑系统开发？
<span class="number">3</span>.生产环境如何搭建（比如很多前端的生产环境是基于php，也有基于NodeJs）
<span class="number">4</span>.编译环境如何搭建（编译环境其实应该归到生产环境中，但前端很多人使用coffeescript<span class="regexp">/less/</span>sass等，所以需要编译环境）
<span class="number">5</span>.单元测试环境如何搭建？
<span class="number">6</span>.调试环境如何搭建（本地代理远程assets等）
<span class="number">7</span>.开发完毕后打包部署如何处理？
</code></pre><p>我相信多数前端在项目coding前肯定都会碰上类似的问题，你是花半天、1天、2天解决？<br>假如你是多人合作呢？问题更严重，如何保持团队环境和代码规范的一致性？教团队成员装依赖？配置工具？大费口舌告之规范？<br>没做一个项目，你都会遇到相同问题，再重复一遍？<br>亲累不？<br>用yeoman！1行命名，15秒进入coding状态！<br>想尝试下吗？往下看~</p>
<pre><code>YO：Yeoman核心工具，项目工程依赖目录和文件生成工具，项目生产环境和编译环境生成工具
GRUNT：grunt去年很火，前端构建工具，jquery就是使用这个工具打包的
BOWER：Web开发的包管理器，概念上类似<span class="built_in">npm</span>，<span class="built_in">npm</span>专注于nodeJs模块，而bower专注于CSS、JavaScript、图像等前端相关内容的管理
</code></pre><p><strong>Yeoman主要有三部分组成：yo（脚手架工具）、grunt（构建工具）、bower（包管理器）</strong>。<br>这三个工具是分别独立开发的，但是需要配合使用，来实现我们高效的工作流模式。<br>闪电般的初始化：项目开始阶段，可以基于现有的模板框架（例如：HTML5 Bolierplate、Twitter Bootstrap）进行项目初始化的快速构建。<br>了不起的构建流程：不仅仅包括JS、CSS代码的压缩、合并，还可以对图片和HTML文件进行优化，同时对CoffeScript和Compass的文件进行编译。<br>自动编译CoffeScript和Compass：通过LiveReload进程可以对源文件发生的改动自动编译，完成后刷新浏览器。<br>自动Lint代码：对于JS代码会自动进行JSLint测试，确保代码符合最佳编程实践。<br>内置的预览服务器：不再需要自己配置服务器了，使用内置的就可以快速预览。<br>惊人的图片优化：通过使用OptiPNG和JPEGTran来优化图片，减少下载损耗。<br>杀手级包管理：通过bower search jQuery，可以快速安装和更新相关的文件，不再需要打开浏览器自己搜索了。<br>PhantomJS单元测试：可以非常方便的使用PhantomJS进行单元测试，一切在项目初始的时候都准备好了。</p>
<h2 id="需要安装">需要安装</h2>
<pre><code><span class="keyword">ruby</span> gem compass node npm mygit git <span class="keyword">python</span> yeoman(yo grunt bower)
</code></pre><p>须先安装git，因为bower依赖与git下载东西</p>
<h3 id="安装_Ruby：">安装 Ruby：</h3>
<p>注意看好自己的操作系统版本，比如我的是 Win7 64 位，选的就是 Ruby 2.0.0-p195 (x64) 。<br><a href="http://rubyinstaller.org/downloads/" target="_blank" rel="external">http://rubyinstaller.org/downloads/</a><br>用户变量路径：<br>PATH：C:\Ruby200\bin;<br>系统变量：<br>PATH：C:\Ruby200\bin;</p>
<h3 id="gem_compass">gem compass</h3>
<p>Compass 是一个用来开发 CSS 的工具，因为Yeoman 启动的时候需要依赖这个工具，所以是必须安装的。<br>gem update —system<br>gem install compass<br>参考：<a href="http://compass-style.org/install/" target="_blank" rel="external">http://compass-style.org/install/</a></p>
<h3 id="安裝_Git_for_Windows_指令列工具">安裝 Git for Windows 指令列工具</h3>
<p>安裝到 Adjusting your PATH environment 步驟時，選擇 Run Git from the Windows Command Prompt 的相容性比較高，問題也會少很多：<br>系统变量：<br>PATH：C:\Program Files\Git\cmd;C:\Program Files\TortoiseGit\bin;</p>
<p>msysgit是Windows版的Git，从<a href="http://msysgit.github.io/" target="_blank" rel="external">http://msysgit.github.io/</a>下载，然后按默认选项安装即可。<br>安装完成后，还需要最后一步设置，在命令行输入：</p>
<pre><code>$ git config --global <span class="literal">user</span>.name <span class="string">"Your Name"</span>
$ git config --global <span class="literal">user</span>.email <span class="string">"email@example.com"</span>
</code></pre><p>查看git配置命令：<br>查看所有配置</p>
<pre><code>$ git config --<span class="keyword">list</span>
</code></pre><p>查看某个配置</p>
<pre><code>$ git config <span class="literal">user</span>.name
</code></pre><h3 id="安装_NodeJS：">安装 NodeJS：</h3>
<p><a href="http://nodejs.org/download/" target="_blank" rel="external">http://nodejs.org/download/</a><br>npm默认全局路径:<br>C:\Users\shangwenxue\AppData\Roaming\npm<br>C:\Users\shangwenxue\AppData\Roaming\npm\node_modules<br>npm默认的全局路径也可以设置：我建议使用默认的路径，只是知道有这么回事就行了<br>修改npm默认的全局路径:<br>npm config set prefix “C:\Program Files\nodejs\node_global” -g  对应默认的C:\Users\shangwenxue\AppData\Roaming\npm<br>npm config set cache “C:\Program Files\nodejs\node_cache” -g  对应默认的C:\Users\shangwenxue\AppData\Roaming\npm-cache</p>
<p>用户变量路径：<br>PATH：C:\Users\shangwenxue\AppData\Roaming\npm 对应npm的全局路径<br>系统变量：<br>PATH：C:\Program Files\nodejs\;<br>NODE_PATH：C:\Users\shangwenxue\AppData\Roaming\npm\node_modules  对应npm的全局路径下的node_modules</p>
<p>node/ node执行程序和npm模块</p>
<p>npm/ 默认的全局模块安装路径前缀</p>
<p>npm-cache/ npm安装模块的缓存目录，离线状态可以从这里读取方便安装</p>
<p>.npmrc 文本文件，存放npm的userconfig配置（后面会提到）<br>备注：我在安装时，在user/我/.npmrc  一开始存在.npmrc这文件一直安装不上去，后边删除就好了。</p>
<h3 id="安装_python_环境：">安装 python 环境：</h3>
<p>安装教程：<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001374738150500472fd5785c194ebea336061163a8a974000" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001374738150500472fd5785c194ebea336061163a8a974000</a><br>系统变量：<br>PATH：C:\Python34</p>
<h2 id="查看版本是否安装成功：">查看版本是否安装成功：</h2>
<pre><code><span class="keyword">ruby</span> --<span class="keyword">version</span> &amp;&amp; gem --<span class="keyword">version</span> &amp;&amp; node --<span class="keyword">version</span> &amp;&amp; npm --<span class="keyword">version</span> &amp;&amp; git --<span class="keyword">version</span> &amp;&amp; <span class="keyword">python</span> --<span class="keyword">version</span>
</code></pre><h3 id="yeoman安装好后可查看：">yeoman安装好后可查看：</h3>
<pre><code>yo --<span class="keyword">version</span> &amp;&amp; bower --<span class="keyword">version</span> &amp;&amp; grunt --<span class="keyword">version</span>
</code></pre><h2 id="安装_Yeoman：">安装 Yeoman：</h2>
<p>首先安装 yo，这会自动安装 grunt, bower</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> -g yo
npm <span class="keyword">install</span> -g generator-webapp

npm <span class="keyword">install</span> -g yo grunt-cli bower</span>
</code></pre><p>其中 -g 代表要把 yo , grunt-cli , bower 這三個套件安裝到全域 (global)<br>npm install -g yo（yo grunt-cli bower）<br>安裝 yo 相關的 程式碼產生器 (generator) 套件<br>因為 yo 這套工具主要就是用來自動產生 網站骨架 或 程式碼 ，在執行 yo 之前，你必須預先安裝好這些程式碼產生器範本，這些被稱為 YEOMAN GENERATORS ，你可以在 YEOMAN GENERATORS 找到許多現成的產生器範本，並且一樣透過 npm 進行安裝。</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> -g generator-mocha</span>
</code></pre><p>例如你在 YEOMAN GENERATORS 頁面找到一個 webapp 產生器，那麼你可以用以下指令進行安裝：</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> -g generator-webapp</span>
</code></pre><p>如果想安裝 angular 產生器，那麼你可以用以下指令進行安裝：</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> -g generator-angular</span>
</code></pre><p>以此類推！</p>
<h2 id="创建工程:">创建工程:</h2>
<pre><code><span class="built_in">cd</span> test
</code></pre><p>使用 yo 指令產生網站骨架，我們使用 webapp 這個 產生器 ( generator ) 來建立網站，指令如下：</p>
<pre><code><span class="title">yo</span> webapp
</code></pre><p>会询问我们是否使用Bootstrap和RequireJS及其它相关东西，我这里都选择了是。完成后一个Web应用的基础框架就建立好了。<br>添加JS库，这里添加 backbone，bower 会自动下载 underscore.</p>
<pre><code>bower <span class="operator"><span class="keyword">install</span> <span class="comment">--save backbone</span></span>
</code></pre><p>如果工程中需要其它类库，也可以使用命令方便的添加，例如添加 underscore：</p>
<pre><code>bower <span class="operator"><span class="keyword">install</span> <span class="comment">--save underscore</span>
bower list(可以查看类库文件间的相互依赖关系)

bower search jquery-ui
bower <span class="keyword">uninstall</span> jquery-ui

bower <span class="keyword">install</span> <span class="comment">--save angular-ui-sortable</span>
bower <span class="keyword">install</span> <span class="comment">--save jquery-ui</span></span>
</code></pre><p>其中 —save 选项帮助你更新 bower.jason,省却你以后手动更新的麻烦。</p>
<p>在app文件夹里如果总少一个bower_components 文件夹。应该是Git没装全。把Git装好后，重走一次前面的步骤，就会好了。所以，切记，先安装好Git，再装Yeoman。<br>初始化的WebApp目录结构如下，app目录是我们项目的主目录，test目录中对应的一些JS的单元测试文件。</p>
<h2 id="启动工程服务:">启动工程服务:</h2>
<pre><code>grunt --<span class="keyword">help</span>
</code></pre><p>這裡就定義了四個自訂工作，分別是：<br>| <code>server</code>  | 這個工作會包含執行其他多項工作，並且依序執行，如 clean:server, concurrent:server, …|<br>| <code>test</code>    | 這裡會執行該網站的相關自動化測試工作，最後一項工作則是執行 mocha 工作 ( 註: mocha 是一套 JavaScript 測試框架 )。|<br>| <code>build</code>   | 用來執行一連串相關工作，主要目的是將網站建置為乾淨且可佈署的檔案，包含 css, js 檔案的最小化動作，並將所有需要部屬的檔案複製到 dist 目錄下。|<br>| <code>default</code> | 用來定義預設的工作，也就是單純執行 grunt 指令時要執行的工作項目。|</p>
<p>所以，如果我們想執行 build 工作，直接輸入 grunt build 即可：<br>Yeoman 内置 Node 服务。启动命令</p>
<pre><code>grunt <span class="keyword">server</span>
</code></pre><p>服务启动后会自动打开浏览器访问<a href="http://localhost:9000/（端口号可以在" target="_blank" rel="external">http://localhost:9000/（端口号可以在</a> gruntfile.js 中配置）</p>
<pre><code><span class="title">grunt</span> build
</code></pre><p>生成dist文件夹</p>
<h3 id="小知识点：">小知识点：</h3>
<p>npm清除缓存命令：</p>
<pre><code>npm <span class="operator"><span class="keyword">cache</span> clean</span>
</code></pre><h4 id="nodejs_npm目录配置方法：">nodejs npm目录配置方法：</h4>
<pre><code><span class="number">1.</span>输入 npm config ls -l 可以查看当前的目录设置
<span class="number">2.</span> 针对某一项设置，可以通过
npm config <span class="keyword">set</span> 属性名 属性值
的方式来进行配置。
例如:
npm config <span class="keyword">set</span> prefix <span class="string">"C:\123\"</span>
<span class="number">3.</span> 读取某一项配置
npm config <span class="keyword">get</span> prefix
nodejs npm config
</code></pre><h5 id="npm的常用命令：">npm的常用命令：</h5>
<p>代码如下:</p>
<pre><code><span class="built_in">npm</span> install xxx 安装模块
<span class="built_in">npm</span> install xxx@<span class="number">1.1</span><span class="number">.1</span>   安装<span class="number">1.1</span><span class="number">.1</span>版本的xxx
<span class="built_in">npm</span> install xxx -g 将模块安装到全局环境中。
<span class="built_in">npm</span> ls 查看安装的模块及依赖
<span class="built_in">npm</span> ls -g 查看全局安装的模块及依赖
<span class="built_in">npm</span> uninstall xxx  (-g) 卸载模块
<span class="built_in">npm</span> cache clean 清理缓存
<span class="built_in">npm</span> help xxx  查看帮助
<span class="built_in">npm</span> view moudlename dependencies  查看包的依赖关系
<span class="built_in">npm</span> view modulenames  查看node模块的package.json文件夹
<span class="built_in">npm</span> view modulename labelname  查看package.json文件夹下某个标签的内容
<span class="built_in">npm</span> view modulename repository.url  查看包的源文件地址
<span class="built_in">npm</span> view modulename engines   查看包所依赖的node的版本
<span class="built_in">npm</span> help folders   查看<span class="built_in">npm</span>使用的所有文件夹
<span class="built_in">npm</span> rebuild modulename    用于更改包内容后进行重建
<span class="built_in">npm</span> outdated   检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新
<span class="built_in">npm</span> update modulename   更新node模块
</code></pre><p>参考：<a href="http://www.tuicool.com/articles/ENbI7j3" target="_blank" rel="external">http://www.tuicool.com/articles/ENbI7j3</a><br><a href="http://chuo.me/2013/02/twitter-bower.html" target="_blank" rel="external">http://chuo.me/2013/02/twitter-bower.html</a><br><a href="http://www.36ria.com/6144" target="_blank" rel="external">http://www.36ria.com/6144</a><br><a href="http://yeoman.io/learning/" target="_blank" rel="external">http://yeoman.io/learning/</a><br><a href="http://blog.fens.me/series-nodejs/" target="_blank" rel="external">http://blog.fens.me/series-nodejs/</a><br><a href="http://yeoman.io/learning/resources.html" target="_blank" rel="external">http://yeoman.io/learning/resources.html</a></p>
<h2 id="运行过程的全部命令：">运行过程的全部命令：</h2>
<h3 id="1、运行start_command_prompt_with_ruby:">1、运行start command prompt with ruby:</h3>
<pre><code>gem <span class="operator"><span class="keyword">update</span> <span class="comment">--system</span>
gem <span class="keyword">install</span> compass</span>
</code></pre><p>上面命令产生文件在 C:\Ruby200\bin 这个文件夹底下能够找到对应的</p>
<h3 id="2、运行node-js_command_prompt：">2、运行node.js command prompt：</h3>
<pre><code><span class="keyword">ruby</span> --<span class="keyword">version</span> &amp;&amp; gem --<span class="keyword">version</span> &amp;&amp; node --<span class="keyword">version</span> &amp;&amp; npm --<span class="keyword">version</span> &amp;&amp; git --<span class="keyword">version</span> &amp;&amp; <span class="keyword">python</span> --<span class="keyword">version</span>

npm install -<span class="keyword">g</span> yo grunt-cli bower
npm install -<span class="keyword">g</span> generator-webapp
npm install -<span class="keyword">g</span> generator-mocha
npm install -<span class="keyword">g</span> generator-angular

yo --<span class="keyword">version</span> &amp;&amp; bower --<span class="keyword">version</span> &amp;&amp; grunt --<span class="keyword">version</span>
</code></pre><p>上面命令产生文件在 C:\Users\shangwenxue\AppData\Roaming\npm 这个文件夹底下能够找到对应的</p>
<h3 id="3、运行node-js_command_prompt：">3、运行node.js command prompt：</h3>
<pre><code>cd test
yo webapp
bower <span class="operator"><span class="keyword">install</span> <span class="comment">--save backbone</span>
bower <span class="keyword">install</span> <span class="comment">--save underscore</span>
bower <span class="keyword">install</span> <span class="comment">--save angular-ui-sortable</span>
bower <span class="keyword">install</span> <span class="comment">--save jquery-ui</span>
grunt <span class="comment">--help</span>
grunt <span class="keyword">server</span>
grunt build</span>
</code></pre><p>上面命令产生文件在 D:\test及D:\test\bower_components 这个文件夹底下能够找到对应的</p>
]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[markdownpad2.md]]></title>
    <link href="http://pleasureswx123.github.io/2014/09/11/markdownpad2md/"/>
    <id>http://pleasureswx123.github.io/2014/09/11/markdownpad2md/</id>
    <published>2014-09-11T11:29:58.000Z</published>
    <updated>2014-09-11T11:38:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="markdownpad2的安装">markdownpad2的安装</h1>
<ul>
<li>markdownpad2文件<a href="http://pan.baidu.com/s/1bCtQ2" title="markdownpad2" target="_blank" rel="external">下载地址</a><br>  <img src="/img/markdownpad2/1.png" alt="markdownpad1"><br>  <img src="/img/markdownpad2/2.png" alt="markdownpad2"></li>
<li>markdown密钥生成机<a href="http://pan.baidu.com/s/1bnivSwZ" title="markdown密钥" target="_blank" rel="external">下载地址</a><br>  <img src="/img/markdownpad2/3.png" alt="markdownpadkey"></li>
</ul>
<p>小用了一下：<br><a href="http://weibotuchuang.sinaapp.com/" title="图床" target="_blank" rel="external">围脖图床</a><br>好像不稳定</p>
<p>个人感觉markdownpad2非常不错，分享出去，有需要的可以试试。</p>
]]></content>
    
    
  </entry>
  
</feed>
